{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n * @module methodWrapper\n *\n */\n\n\nimport * as store from '../store';\nimport { onMount, onUnmount, _onKeyDown } from '../event_handlers';\n/**\n * _isReactKeyDown\n *\n * @access private\n * @param {object} event The possibly synthetic event passed as an argument with\n * the method invocation.\n * @return {boolean}\n */\n\nfunction _isReactKeyDown(event) {\n  return event && (typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' && event.nativeEvent instanceof window.KeyboardEvent && event.type === 'keydown';\n}\n/**\n * methodWrapper\n *\n * @access public\n * @param {object} args All arguments necessary for wrapping method\n * @param {object} args.target The decorated class\n * @param {object} args.descriptor Method descriptor\n * @param {array} args.keys The array of keys bound to the given method\n * @return {object} The method descriptor\n */\n\n\nfunction methodWrapper(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n  var fn = descriptor.value; // if we haven't already created a binding for this class (via another\n  // decorated method), wrap these lifecycle methods.\n\n  if (!store.getBinding(target)) {\n    var componentDidMount = target.componentDidMount,\n        componentWillUnmount = target.componentWillUnmount;\n\n    target.componentDidMount = function () {\n      onMount(this);\n      if (componentDidMount) return componentDidMount.call(this);\n    };\n\n    target.componentWillUnmount = function () {\n      onUnmount(this);\n      if (componentWillUnmount) return componentWillUnmount.call(this);\n    };\n  } // add this binding of keys and method to the target's bindings\n\n\n  store.setBinding({\n    keys: keys,\n    target: target,\n    fn: fn\n  });\n\n  descriptor.value = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var maybeEvent = args[0];\n\n    if (_isReactKeyDown(maybeEvent)) {\n      // proxy method in order to use @keydown as filter for keydown events coming\n      // from an actual onKeyDown binding (as identified by react's addition of\n      // 'nativeEvent' + type === 'keydown')\n      if (!maybeEvent.ctrlKey) {\n        // we already whitelist shortcuts with ctrl modifiers so if we were to\n        // fire it again here the method would trigger twice. see https://github.com/glortho/react-keydown/issues/38\n        return _onKeyDown(maybeEvent, true);\n      }\n    } else if (!maybeEvent || !(maybeEvent instanceof window.KeyboardEvent) || maybeEvent.type !== 'keydown') {\n      // if our first argument is a keydown event it is being handled by our\n      // binding system. if it's anything else, just pass through.\n      return fn.call.apply(fn, [this].concat(args));\n    }\n  };\n\n  return descriptor;\n}\n\nexport default methodWrapper;","map":{"version":3,"sources":["/Users/steve/Documents/repos/notifications/node_modules/react-keydown/es/decorators/method_decorator.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","store","onMount","onUnmount","_onKeyDown","_isReactKeyDown","event","nativeEvent","window","KeyboardEvent","type","methodWrapper","_ref","target","descriptor","keys","fn","value","getBinding","componentDidMount","componentWillUnmount","call","setBinding","_len","arguments","length","args","Array","_key","maybeEvent","ctrlKey","apply","concat"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @module methodWrapper\n *\n */\nimport * as store from '../store';\nimport { onMount, onUnmount, _onKeyDown } from '../event_handlers';\n\n/**\n * _isReactKeyDown\n *\n * @access private\n * @param {object} event The possibly synthetic event passed as an argument with\n * the method invocation.\n * @return {boolean}\n */\nfunction _isReactKeyDown(event) {\n  return event && (typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' && event.nativeEvent instanceof window.KeyboardEvent && event.type === 'keydown';\n}\n\n/**\n * methodWrapper\n *\n * @access public\n * @param {object} args All arguments necessary for wrapping method\n * @param {object} args.target The decorated class\n * @param {object} args.descriptor Method descriptor\n * @param {array} args.keys The array of keys bound to the given method\n * @return {object} The method descriptor\n */\nfunction methodWrapper(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n\n\n  var fn = descriptor.value;\n\n  // if we haven't already created a binding for this class (via another\n  // decorated method), wrap these lifecycle methods.\n  if (!store.getBinding(target)) {\n    var componentDidMount = target.componentDidMount,\n        componentWillUnmount = target.componentWillUnmount;\n\n\n    target.componentDidMount = function () {\n      onMount(this);\n      if (componentDidMount) return componentDidMount.call(this);\n    };\n\n    target.componentWillUnmount = function () {\n      onUnmount(this);\n      if (componentWillUnmount) return componentWillUnmount.call(this);\n    };\n  }\n\n  // add this binding of keys and method to the target's bindings\n  store.setBinding({ keys: keys, target: target, fn: fn });\n\n  descriptor.value = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var maybeEvent = args[0];\n\n    if (_isReactKeyDown(maybeEvent)) {\n      // proxy method in order to use @keydown as filter for keydown events coming\n      // from an actual onKeyDown binding (as identified by react's addition of\n      // 'nativeEvent' + type === 'keydown')\n      if (!maybeEvent.ctrlKey) {\n        // we already whitelist shortcuts with ctrl modifiers so if we were to\n        // fire it again here the method would trigger twice. see https://github.com/glortho/react-keydown/issues/38\n        return _onKeyDown(maybeEvent, true);\n      }\n    } else if (!maybeEvent || !(maybeEvent instanceof window.KeyboardEvent) || maybeEvent.type !== 'keydown') {\n      // if our first argument is a keydown event it is being handled by our\n      // binding system. if it's anything else, just pass through.\n      return fn.call.apply(fn, [this].concat(args));\n    }\n  };\n\n  return descriptor;\n}\n\nexport default methodWrapper;"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n * @module decorators\n *\n */\n\n\nimport classWrapper from './class_decorator';\nimport methodWrapper from './method_decorator';\nimport methodWrapperScoped from './method_decorator_scoped';\n/**\n * noopDecorator\n *\n * @access private\n * @return {undefined} Returns `undefined` so that the original undecorated instance/method is used\n */\n\nfunction noopDecorator() {\n  return undefined;\n}\n/**\n * _decorator\n *\n * @access private\n * @param {Function} methodFn The method wrapper to delegate to, based on whether user has specified a scoped decorator or not\n * @param {Array} ...args Remainder of arguments passed in\n * @return {Function} The decorated class or method\n */\n\n\nfunction _decorator(methodFn) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  } // check the first argument to see if it's a user-supplied keycode or array\n  // of keycodes, or if it's the wrapped class or method\n\n\n  var testArg = args[0];\n  var isArray = Array.isArray(testArg); // if the test argument is not an object or function, it is user-supplied\n  // keycodes. else there are no arguments and it's just the wrapped class\n\n  if (isArray || ~['string', 'number', 'symbol'].indexOf(typeof testArg === 'undefined' ? 'undefined' : _typeof(testArg))) {\n    var keys = isArray ? testArg : args; // return the decorator function, which on the next call will look for\n    // the presence of a method name to determine if this is a wrapped method\n    // or component\n\n    return function (target, methodName, descriptor) {\n      return methodName ? methodFn({\n        target: target,\n        descriptor: descriptor,\n        keys: keys\n      }) : classWrapper(target, keys);\n    };\n  } else {\n    var WrappedComponent = args[0];\n    var methodName = args[1]; // method decorators without keycode (which) arguments are not allowed.\n\n    if (WrappedComponent && !methodName) {\n      return classWrapper.apply(undefined, args);\n    } else {\n      console.warn(methodName + ': Method decorators must have keycode arguments, so the decorator for this method will not do anything');\n      return noopDecorator;\n    }\n  }\n}\n/**\n * keydownScoped\n *\n * Method decorator that will look for changes to its targeted component's\n * `keydown` props to decide when to trigger, rather than responding directly\n * to keydown events. This lets you specify a @keydown decorated class higher\n * up in the view hierarchy for larger scoping of keydown events, or for\n * programmatically sending keydown events as props into the components in order\n * to trigger decorated methods with matching keys.\n *\n * @access public\n * @param {Array} ...args  All (or no) arguments passed in from decoration\n * @return {Function} The decorated class or method\n */\n\n\nfunction keydownScoped() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _decorator.apply(undefined, [methodWrapperScoped].concat(args));\n}\n/**\n * keydown\n *\n * The main decorator and default export, handles both classes and methods.\n *\n * @access public\n * @param {Array} ...args  All (or no) arguments passed in from decoration\n * @return {Function} The decorated class or method\n */\n\n\nfunction keydown() {\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _decorator.apply(undefined, [methodWrapper].concat(args));\n}\n\nexport default keydown;\nexport { keydownScoped };","map":{"version":3,"sources":["/Users/steve/Documents/repos/github-notifications/node_modules/react-keydown/es/decorators/index.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","classWrapper","methodWrapper","methodWrapperScoped","noopDecorator","undefined","_decorator","methodFn","_len","arguments","length","args","Array","_key","testArg","isArray","indexOf","keys","target","methodName","descriptor","WrappedComponent","apply","console","warn","keydownScoped","_len2","_key2","concat","keydown","_len3","_key3"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @module decorators\n *\n */\nimport classWrapper from './class_decorator';\nimport methodWrapper from './method_decorator';\nimport methodWrapperScoped from './method_decorator_scoped';\n\n/**\n * noopDecorator\n *\n * @access private\n * @return {undefined} Returns `undefined` so that the original undecorated instance/method is used\n */\nfunction noopDecorator() {\n  return undefined;\n}\n\n/**\n * _decorator\n *\n * @access private\n * @param {Function} methodFn The method wrapper to delegate to, based on whether user has specified a scoped decorator or not\n * @param {Array} ...args Remainder of arguments passed in\n * @return {Function} The decorated class or method\n */\nfunction _decorator(methodFn) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  // check the first argument to see if it's a user-supplied keycode or array\n  // of keycodes, or if it's the wrapped class or method\n  var testArg = args[0];\n  var isArray = Array.isArray(testArg);\n\n  // if the test argument is not an object or function, it is user-supplied\n  // keycodes. else there are no arguments and it's just the wrapped class\n  if (isArray || ~['string', 'number', 'symbol'].indexOf(typeof testArg === 'undefined' ? 'undefined' : _typeof(testArg))) {\n    var keys = isArray ? testArg : args;\n\n    // return the decorator function, which on the next call will look for\n    // the presence of a method name to determine if this is a wrapped method\n    // or component\n    return function (target, methodName, descriptor) {\n      return methodName ? methodFn({ target: target, descriptor: descriptor, keys: keys }) : classWrapper(target, keys);\n    };\n  } else {\n    var WrappedComponent = args[0];\n    var methodName = args[1];\n\n    // method decorators without keycode (which) arguments are not allowed.\n    if (WrappedComponent && !methodName) {\n      return classWrapper.apply(undefined, args);\n    } else {\n      console.warn(methodName + ': Method decorators must have keycode arguments, so the decorator for this method will not do anything');\n      return noopDecorator;\n    }\n  }\n}\n\n/**\n * keydownScoped\n *\n * Method decorator that will look for changes to its targeted component's\n * `keydown` props to decide when to trigger, rather than responding directly\n * to keydown events. This lets you specify a @keydown decorated class higher\n * up in the view hierarchy for larger scoping of keydown events, or for\n * programmatically sending keydown events as props into the components in order\n * to trigger decorated methods with matching keys.\n *\n * @access public\n * @param {Array} ...args  All (or no) arguments passed in from decoration\n * @return {Function} The decorated class or method\n */\nfunction keydownScoped() {\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return _decorator.apply(undefined, [methodWrapperScoped].concat(args));\n}\n\n/**\n * keydown\n *\n * The main decorator and default export, handles both classes and methods.\n *\n * @access public\n * @param {Array} ...args  All (or no) arguments passed in from decoration\n * @return {Function} The decorated class or method\n */\nfunction keydown() {\n  for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return _decorator.apply(undefined, [methodWrapper].concat(args));\n}\n\nexport default keydown;\n\nexport { keydownScoped };"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { useRef } from 'react';\nimport useLayoutEffect from '../utils/useIsomorphicLayoutEffect';\n/**\n * Creates a ref by combining multiple constituent refs. The ref returned by this hook\n * should be passed as the ref for the element that needs to be shared. This is\n * particularly useful when you are using `React.forwardRef` in your component but you\n * also want to be able to access the local element. This is a small anti-pattern,\n * though, as it breaks encapsulation.\n * @param refs\n */\n\nexport function useCombinedRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  const combinedRef = useRef(null);\n  useLayoutEffect(() => {\n    function setRefs() {\n      let current = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      for (const ref of refs) {\n        if (!ref) {\n          return;\n        }\n\n        if (typeof ref === 'function') {\n          ref(current);\n        } else {\n          ref.current = current;\n        }\n      }\n    }\n\n    setRefs(combinedRef.current);\n    return () => {\n      // ensure the refs get updated on unmount\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      setRefs(combinedRef.current);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...refs, combinedRef.current]);\n  return combinedRef;\n}","map":{"version":3,"sources":["/Users/steve/Documents/repos/github-notifications/node_modules/@primer/react/lib-esm/hooks/useCombinedRefs.js"],"names":["useRef","useLayoutEffect","useCombinedRefs","refs","combinedRef","setRefs","current","ref"],"mappings":"AAAA,SAASA,MAAT,QAAuB,OAAvB;AACA,OAAOC,eAAP,MAA4B,oCAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,eAAT,GAAkC;AAAA,oCAANC,IAAM;AAANA,IAAAA,IAAM;AAAA;;AACvC,QAAMC,WAAW,GAAGJ,MAAM,CAAC,IAAD,CAA1B;AACAC,EAAAA,eAAe,CAAC,MAAM;AACpB,aAASI,OAAT,GAAiC;AAAA,UAAhBC,OAAgB,uEAAN,IAAM;;AAC/B,WAAK,MAAMC,GAAX,IAAkBJ,IAAlB,EAAwB;AACtB,YAAI,CAACI,GAAL,EAAU;AACR;AACD;;AAED,YAAI,OAAOA,GAAP,KAAe,UAAnB,EAA+B;AAC7BA,UAAAA,GAAG,CAACD,OAAD,CAAH;AACD,SAFD,MAEO;AACLC,UAAAA,GAAG,CAACD,OAAJ,GAAcA,OAAd;AACD;AACF;AACF;;AAEDD,IAAAA,OAAO,CAACD,WAAW,CAACE,OAAb,CAAP;AACA,WAAO,MAAM;AACX;AACA;AACAD,MAAAA,OAAO,CAACD,WAAW,CAACE,OAAb,CAAP;AACD,KAJD,CAhBoB,CAoBjB;AACJ,GArBc,EAqBZ,CAAC,GAAGH,IAAJ,EAAUC,WAAW,CAACE,OAAtB,CArBY,CAAf;AAsBA,SAAOF,WAAP;AACD","sourcesContent":["import { useRef } from 'react';\nimport useLayoutEffect from '../utils/useIsomorphicLayoutEffect';\n/**\n * Creates a ref by combining multiple constituent refs. The ref returned by this hook\n * should be passed as the ref for the element that needs to be shared. This is\n * particularly useful when you are using `React.forwardRef` in your component but you\n * also want to be able to access the local element. This is a small anti-pattern,\n * though, as it breaks encapsulation.\n * @param refs\n */\n\nexport function useCombinedRefs(...refs) {\n  const combinedRef = useRef(null);\n  useLayoutEffect(() => {\n    function setRefs(current = null) {\n      for (const ref of refs) {\n        if (!ref) {\n          return;\n        }\n\n        if (typeof ref === 'function') {\n          ref(current);\n        } else {\n          ref.current = current;\n        }\n      }\n    }\n\n    setRefs(combinedRef.current);\n    return () => {\n      // ensure the refs get updated on unmount\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      setRefs(combinedRef.current);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [...refs, combinedRef.current]);\n  return combinedRef;\n}"]},"metadata":{},"sourceType":"module"}
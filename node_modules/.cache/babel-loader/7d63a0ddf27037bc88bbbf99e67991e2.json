{"ast":null,"code":"/**\n * @module domHelpers\n *\n */\nimport ReactDOM from 'react-dom';\nvar focusableSelector = 'a[href], button, input, object, select, textarea, [tabindex]';\n/**\n * bindFocusables: Find any focusable child elements of the component instance and\n * add an onFocus handler to focus our keydown handlers on the parent component\n * when user keys applies focus to the element.\n *\n * NOTE: One limitation of this right now is that if you tab out of the\n * component, _focusedInstance will still be set until next click or mount or\n * controlled focus.\n *\n * @access public\n * @param {object} instance The key-bound component instance\n * @param {callback} activateOnFocus The fn to fire when element is focused\n */\n\nfunction bindFocusables(instance, activateOnFocus) {\n  if (document.querySelectorAll) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n\n      if (node) {\n        var focusables = node.querySelectorAll(focusableSelector);\n\n        if (focusables.length) {\n          var onFocus = function onFocus(element) {\n            var onFocusPrev = element.onfocus;\n            return function (event) {\n              activateOnFocus(instance);\n              if (onFocusPrev) onFocusPrev.call(element, event);\n            };\n          };\n\n          Array.prototype.slice.call(focusables).forEach(function (element) {\n            return element.onfocus = onFocus(element);\n          });\n        }\n      }\n    } catch (error) {// noop, mostly suppressing error here https://github.com/glortho/react-keydown/issues/76\n    }\n  }\n}\n/**\n * findContainerNodes: Called by our click handler to find instances with nodes\n * that are equal to or that contain the click target. Any that pass this test\n * will be recipients of the next keydown event.\n *\n * @access public\n * @param {object} target The click event.target DOM element\n * @return {function} Reducer function\n */\n\n\nfunction findContainerNodes(target) {\n  return function (memo, instance) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n\n      if (node && (node === target || node.contains(target))) {\n        memo.push({\n          instance: instance,\n          node: node\n        });\n      }\n    } finally {\n      return memo;\n    }\n  };\n}\n/**\n * sortByDOMPosition: Called by our click handler to sort a list of instances\n * according to least -> most nested. This is so that if multiple keybound\n * instances have nodes that are ancestors of the click target, they will be\n * sorted to let the instance closest to the click target get first dibs on the\n * next key down event.\n */\n\n\nfunction sortByDOMPosition(a, b) {\n  return a.node.compareDocumentPosition(b.node) === 10 ? 1 : -1;\n}\n\nexport default {\n  bindFocusables: bindFocusables,\n  findContainerNodes: findContainerNodes,\n  sortByDOMPosition: sortByDOMPosition\n};","map":{"version":3,"sources":["/Users/steve/Documents/repos/notifications/node_modules/react-keydown/es/lib/dom_helpers.js"],"names":["ReactDOM","focusableSelector","bindFocusables","instance","activateOnFocus","document","querySelectorAll","node","findDOMNode","focusables","length","onFocus","element","onFocusPrev","onfocus","event","call","Array","prototype","slice","forEach","error","findContainerNodes","target","memo","contains","push","sortByDOMPosition","a","b","compareDocumentPosition"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,QAAP,MAAqB,WAArB;AAEA,IAAIC,iBAAiB,GAAG,8DAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,QAAxB,EAAkCC,eAAlC,EAAmD;AACjD,MAAIC,QAAQ,CAACC,gBAAb,EAA+B;AAC7B,QAAI;AACF,UAAIC,IAAI,GAAGP,QAAQ,CAACQ,WAAT,CAAqBL,QAArB,CAAX;;AACA,UAAII,IAAJ,EAAU;AACR,YAAIE,UAAU,GAAGF,IAAI,CAACD,gBAAL,CAAsBL,iBAAtB,CAAjB;;AACA,YAAIQ,UAAU,CAACC,MAAf,EAAuB;AACrB,cAAIC,OAAO,GAAG,SAASA,OAAT,CAAiBC,OAAjB,EAA0B;AACtC,gBAAIC,WAAW,GAAGD,OAAO,CAACE,OAA1B;AACA,mBAAO,UAAUC,KAAV,EAAiB;AACtBX,cAAAA,eAAe,CAACD,QAAD,CAAf;AACA,kBAAIU,WAAJ,EAAiBA,WAAW,CAACG,IAAZ,CAAiBJ,OAAjB,EAA0BG,KAA1B;AAClB,aAHD;AAID,WAND;;AAOAE,UAAAA,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBH,IAAtB,CAA2BP,UAA3B,EAAuCW,OAAvC,CAA+C,UAAUR,OAAV,EAAmB;AAChE,mBAAOA,OAAO,CAACE,OAAR,GAAkBH,OAAO,CAACC,OAAD,CAAhC;AACD,WAFD;AAGD;AACF;AACF,KAjBD,CAiBE,OAAOS,KAAP,EAAc,CACd;AACD;AACF;AACF;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,kBAAT,CAA4BC,MAA5B,EAAoC;AAClC,SAAO,UAAUC,IAAV,EAAgBrB,QAAhB,EAA0B;AAC/B,QAAI;AACF,UAAII,IAAI,GAAGP,QAAQ,CAACQ,WAAT,CAAqBL,QAArB,CAAX;;AACA,UAAII,IAAI,KAAKA,IAAI,KAAKgB,MAAT,IAAmBhB,IAAI,CAACkB,QAAL,CAAcF,MAAd,CAAxB,CAAR,EAAwD;AACtDC,QAAAA,IAAI,CAACE,IAAL,CAAU;AAAEvB,UAAAA,QAAQ,EAAEA,QAAZ;AAAsBI,UAAAA,IAAI,EAAEA;AAA5B,SAAV;AACD;AACF,KALD,SAKU;AACR,aAAOiB,IAAP;AACD;AACF,GATD;AAUD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,iBAAT,CAA2BC,CAA3B,EAA8BC,CAA9B,EAAiC;AAC/B,SAAOD,CAAC,CAACrB,IAAF,CAAOuB,uBAAP,CAA+BD,CAAC,CAACtB,IAAjC,MAA2C,EAA3C,GAAgD,CAAhD,GAAoD,CAAC,CAA5D;AACD;;AAED,eAAe;AAAEL,EAAAA,cAAc,EAAEA,cAAlB;AAAkCoB,EAAAA,kBAAkB,EAAEA,kBAAtD;AAA0EK,EAAAA,iBAAiB,EAAEA;AAA7F,CAAf","sourcesContent":["/**\n * @module domHelpers\n *\n */\nimport ReactDOM from 'react-dom';\n\nvar focusableSelector = 'a[href], button, input, object, select, textarea, [tabindex]';\n\n/**\n * bindFocusables: Find any focusable child elements of the component instance and\n * add an onFocus handler to focus our keydown handlers on the parent component\n * when user keys applies focus to the element.\n *\n * NOTE: One limitation of this right now is that if you tab out of the\n * component, _focusedInstance will still be set until next click or mount or\n * controlled focus.\n *\n * @access public\n * @param {object} instance The key-bound component instance\n * @param {callback} activateOnFocus The fn to fire when element is focused\n */\nfunction bindFocusables(instance, activateOnFocus) {\n  if (document.querySelectorAll) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n      if (node) {\n        var focusables = node.querySelectorAll(focusableSelector);\n        if (focusables.length) {\n          var onFocus = function onFocus(element) {\n            var onFocusPrev = element.onfocus;\n            return function (event) {\n              activateOnFocus(instance);\n              if (onFocusPrev) onFocusPrev.call(element, event);\n            };\n          };\n          Array.prototype.slice.call(focusables).forEach(function (element) {\n            return element.onfocus = onFocus(element);\n          });\n        }\n      }\n    } catch (error) {\n      // noop, mostly suppressing error here https://github.com/glortho/react-keydown/issues/76\n    }\n  }\n}\n\n/**\n * findContainerNodes: Called by our click handler to find instances with nodes\n * that are equal to or that contain the click target. Any that pass this test\n * will be recipients of the next keydown event.\n *\n * @access public\n * @param {object} target The click event.target DOM element\n * @return {function} Reducer function\n */\nfunction findContainerNodes(target) {\n  return function (memo, instance) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n      if (node && (node === target || node.contains(target))) {\n        memo.push({ instance: instance, node: node });\n      }\n    } finally {\n      return memo;\n    }\n  };\n}\n\n/**\n * sortByDOMPosition: Called by our click handler to sort a list of instances\n * according to least -> most nested. This is so that if multiple keybound\n * instances have nodes that are ancestors of the click target, they will be\n * sorted to let the instance closest to the click target get first dibs on the\n * next key down event.\n */\nfunction sortByDOMPosition(a, b) {\n  return a.node.compareDocumentPosition(b.node) === 10 ? 1 : -1;\n}\n\nexport default { bindFocusables: bindFocusables, findContainerNodes: findContainerNodes, sortByDOMPosition: sortByDOMPosition };"]},"metadata":{},"sourceType":"module"}
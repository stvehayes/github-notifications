{"ast":null,"code":"import { modifiers as modifierKeys, ALL_KEYS, ALL_PRINTABLE_KEYS } from './keys';\nvar PRINTABLE_CHARACTERS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&*()-_+=[]\\\\{}|;\\':\",./<>?£';\nvar modKeys = Object.keys(modifierKeys);\n\nfunction matchKeys(_ref) {\n  var keySet = _ref.keySet,\n      event = _ref.event;\n  var key = keySet.key,\n      _keySet$modifiers = keySet.modifiers,\n      modifiers = _keySet$modifiers === undefined ? [] : _keySet$modifiers;\n  var keysMatch = void 0;\n  keysMatch = key === ALL_KEYS;\n\n  if (key === ALL_PRINTABLE_KEYS) {\n    if (event.key) {\n      // Modern browsers implement `key`, so if `key` is length 1, we have a match. e.g. 'a' for the\n      // a key, or '2' for the 2 key. All other non-printable characters have names, e.g. 'Enter' or 'Backspace'.\n      keysMatch = event.key.length === 1;\n    } else {\n      // For browsers that do no support `event.key`, we test against a list of characters\n      var pressedChar = String.fromCharCode(event.charCode);\n      keysMatch = PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0;\n    }\n  }\n\n  if (key === event.which) {\n    var evtModKeys = modKeys.filter(function (modKey) {\n      return event[modKey + 'Key'];\n    }).sort();\n    keysMatch = modifiers.length === evtModKeys.length && modifiers.every(function (modKey, index) {\n      return evtModKeys[index] === modKey;\n    });\n  }\n\n  return keysMatch;\n}\n\nexport default matchKeys;","map":{"version":3,"sources":["/Users/steve/Documents/repos/notifications/node_modules/react-keydown/es/lib/match_keys.js"],"names":["modifiers","modifierKeys","ALL_KEYS","ALL_PRINTABLE_KEYS","PRINTABLE_CHARACTERS","modKeys","Object","keys","matchKeys","_ref","keySet","event","key","_keySet$modifiers","undefined","keysMatch","length","pressedChar","String","fromCharCode","charCode","indexOf","which","evtModKeys","filter","modKey","sort","every","index"],"mappings":"AAAA,SAASA,SAAS,IAAIC,YAAtB,EAAoCC,QAApC,EAA8CC,kBAA9C,QAAwE,QAAxE;AAEA,IAAIC,oBAAoB,GAAG,kGAA3B;AAEA,IAAIC,OAAO,GAAGC,MAAM,CAACC,IAAP,CAAYN,YAAZ,CAAd;;AAEA,SAASO,SAAT,CAAmBC,IAAnB,EAAyB;AACvB,MAAIC,MAAM,GAAGD,IAAI,CAACC,MAAlB;AAAA,MACIC,KAAK,GAAGF,IAAI,CAACE,KADjB;AAEA,MAAIC,GAAG,GAAGF,MAAM,CAACE,GAAjB;AAAA,MACIC,iBAAiB,GAAGH,MAAM,CAACV,SAD/B;AAAA,MAEIA,SAAS,GAAGa,iBAAiB,KAAKC,SAAtB,GAAkC,EAAlC,GAAuCD,iBAFvD;AAIA,MAAIE,SAAS,GAAG,KAAK,CAArB;AAEAA,EAAAA,SAAS,GAAGH,GAAG,KAAKV,QAApB;;AAEA,MAAIU,GAAG,KAAKT,kBAAZ,EAAgC;AAC9B,QAAIQ,KAAK,CAACC,GAAV,EAAe;AACb;AACA;AACAG,MAAAA,SAAS,GAAGJ,KAAK,CAACC,GAAN,CAAUI,MAAV,KAAqB,CAAjC;AACD,KAJD,MAIO;AACL;AACA,UAAIC,WAAW,GAAGC,MAAM,CAACC,YAAP,CAAoBR,KAAK,CAACS,QAA1B,CAAlB;AACAL,MAAAA,SAAS,GAAGX,oBAAoB,CAACiB,OAArB,CAA6BJ,WAA7B,KAA6C,CAAzD;AACD;AACF;;AAED,MAAIL,GAAG,KAAKD,KAAK,CAACW,KAAlB,EAAyB;AACvB,QAAIC,UAAU,GAAGlB,OAAO,CAACmB,MAAR,CAAe,UAAUC,MAAV,EAAkB;AAChD,aAAOd,KAAK,CAACc,MAAM,GAAG,KAAV,CAAZ;AACD,KAFgB,EAEdC,IAFc,EAAjB;AAGAX,IAAAA,SAAS,GAAGf,SAAS,CAACgB,MAAV,KAAqBO,UAAU,CAACP,MAAhC,IAA0ChB,SAAS,CAAC2B,KAAV,CAAgB,UAAUF,MAAV,EAAkBG,KAAlB,EAAyB;AAC7F,aAAOL,UAAU,CAACK,KAAD,CAAV,KAAsBH,MAA7B;AACD,KAFqD,CAAtD;AAGD;;AAED,SAAOV,SAAP;AACD;;AAED,eAAeP,SAAf","sourcesContent":["import { modifiers as modifierKeys, ALL_KEYS, ALL_PRINTABLE_KEYS } from './keys';\n\nvar PRINTABLE_CHARACTERS = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ~!@#$%^&*()-_+=[]\\\\{}|;\\':\",./<>?£';\n\nvar modKeys = Object.keys(modifierKeys);\n\nfunction matchKeys(_ref) {\n  var keySet = _ref.keySet,\n      event = _ref.event;\n  var key = keySet.key,\n      _keySet$modifiers = keySet.modifiers,\n      modifiers = _keySet$modifiers === undefined ? [] : _keySet$modifiers;\n\n  var keysMatch = void 0;\n\n  keysMatch = key === ALL_KEYS;\n\n  if (key === ALL_PRINTABLE_KEYS) {\n    if (event.key) {\n      // Modern browsers implement `key`, so if `key` is length 1, we have a match. e.g. 'a' for the\n      // a key, or '2' for the 2 key. All other non-printable characters have names, e.g. 'Enter' or 'Backspace'.\n      keysMatch = event.key.length === 1;\n    } else {\n      // For browsers that do no support `event.key`, we test against a list of characters\n      var pressedChar = String.fromCharCode(event.charCode);\n      keysMatch = PRINTABLE_CHARACTERS.indexOf(pressedChar) >= 0;\n    }\n  }\n\n  if (key === event.which) {\n    var evtModKeys = modKeys.filter(function (modKey) {\n      return event[modKey + 'Key'];\n    }).sort();\n    keysMatch = modifiers.length === evtModKeys.length && modifiers.every(function (modKey, index) {\n      return evtModKeys[index] === modKey;\n    });\n  }\n\n  return keysMatch;\n}\n\nexport default matchKeys;"]},"metadata":{},"sourceType":"module"}
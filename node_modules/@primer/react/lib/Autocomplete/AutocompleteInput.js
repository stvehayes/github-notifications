"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _AutocompleteContext = require("./AutocompleteContext");

var _TextInput = _interopRequireDefault(require("../TextInput"));

var _useCombinedRefs = require("../hooks/useCombinedRefs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const AutocompleteInput = /*#__PURE__*/_react.default.forwardRef(({
  as: Component = _TextInput.default,
  onFocus,
  onBlur,
  onChange,
  onKeyDown,
  onKeyUp,
  onKeyPress,
  value,
  ...props
}, forwardedRef) => {
  const autocompleteContext = (0, _react.useContext)(_AutocompleteContext.AutocompleteContext);

  if (autocompleteContext === null) {
    throw new Error('AutocompleteContext returned null values');
  }

  const {
    activeDescendantRef,
    autocompleteSuggestion = '',
    id,
    inputRef,
    inputValue = '',
    isMenuDirectlyActivated,
    setInputValue,
    setShowMenu,
    showMenu
  } = autocompleteContext;
  const combinedInputRef = (0, _useCombinedRefs.useCombinedRefs)(inputRef, forwardedRef);
  const [highlightRemainingText, setHighlightRemainingText] = (0, _react.useState)(true);
  const handleInputFocus = (0, _react.useCallback)(event => {
    onFocus && onFocus(event);
    setShowMenu(true);
  }, [onFocus, setShowMenu]);
  const handleInputBlur = (0, _react.useCallback)(event => {
    onBlur && onBlur(event); // HACK: wait a tick and check the focused element before hiding the autocomplete menu
    // this prevents the menu from hiding when the user is clicking an option in the Autoselect.Menu,
    // but still hides the menu when the user blurs the input by tabbing out or clicking somewhere else on the page

    setTimeout(() => {
      if (document.activeElement !== combinedInputRef.current) {
        setShowMenu(false);
      }
    }, 0);
  }, [onBlur, setShowMenu, combinedInputRef]);
  const handleInputChange = (0, _react.useCallback)(event => {
    onChange && onChange(event);
    setInputValue(event.currentTarget.value);

    if (!showMenu) {
      setShowMenu(true);
    }
  }, [onChange, setInputValue, setShowMenu, showMenu]);
  const handleInputKeyDown = (0, _react.useCallback)(event => {
    var _inputRef$current;

    onKeyDown && onKeyDown(event);

    if (event.key === 'Backspace') {
      setHighlightRemainingText(false);
    }

    if (event.key === 'Escape' && (_inputRef$current = inputRef.current) !== null && _inputRef$current !== void 0 && _inputRef$current.value) {
      setInputValue('');
      inputRef.current.value = '';
    }
  }, [inputRef, setInputValue, setHighlightRemainingText, onKeyDown]);
  const handleInputKeyUp = (0, _react.useCallback)(event => {
    onKeyUp && onKeyUp(event);

    if (event.key === 'Backspace') {
      setHighlightRemainingText(true);
    }
  }, [setHighlightRemainingText, onKeyUp]);
  const onInputKeyPress = (0, _react.useCallback)(event => {
    onKeyPress && onKeyPress(event);

    if (showMenu && event.key === 'Enter' && activeDescendantRef.current) {
      event.preventDefault();
      event.nativeEvent.stopImmediatePropagation(); // Forward Enter key press to active descendant so that item gets activated

      const activeDescendantEvent = new KeyboardEvent(event.type, event.nativeEvent);
      activeDescendantRef.current.dispatchEvent(activeDescendantEvent);
    }
  }, [activeDescendantRef, showMenu, onKeyPress]);
  (0, _react.useEffect)(() => {
    if (!inputRef.current) {
      return;
    } // resets input value to being empty after a selection has been made


    if (!autocompleteSuggestion) {
      inputRef.current.value = inputValue;
    } // TODO: fix bug where this function prevents `onChange` from being triggered if the highlighted item text
    //       is the same as what I'm typing
    //       e.g.: typing 'tw' highlights 'two', but when I 'two', the text input change does not get triggered


    if (highlightRemainingText && autocompleteSuggestion && (inputValue || isMenuDirectlyActivated)) {
      inputRef.current.value = autocompleteSuggestion;

      if (autocompleteSuggestion.toLowerCase().indexOf(inputValue.toLowerCase()) === 0) {
        inputRef.current.setSelectionRange(inputValue.length, autocompleteSuggestion.length);
      }
    } // calling this useEffect when `highlightRemainingText` changes breaks backspace functionality
    // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [autocompleteSuggestion, inputValue, inputRef, isMenuDirectlyActivated]);
  (0, _react.useEffect)(() => {
    setInputValue(typeof value !== 'undefined' ? value.toString() : '');
  }, [value, setInputValue]);
  return /*#__PURE__*/_react.default.createElement(Component, _extends({
    onFocus: handleInputFocus,
    onBlur: handleInputBlur,
    onChange: handleInputChange,
    onKeyDown: handleInputKeyDown,
    onKeyPress: onInputKeyPress,
    onKeyUp: handleInputKeyUp,
    ref: combinedInputRef,
    "aria-controls": `${id}-listbox`,
    "aria-autocomplete": "both",
    role: "combobox",
    "aria-expanded": showMenu,
    "aria-haspopup": "listbox",
    "aria-owns": `${id}-listbox`,
    autoComplete: "off",
    id: id
  }, props));
});

AutocompleteInput.displayName = 'AutocompleteInput';
var _default = AutocompleteInput;
exports.default = _default;
{"ast":null,"code":"const alternateOrders = {\n  'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n  'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n  'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n  'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom']\n};\nconst alternateAlignments = {\n  start: ['end', 'center'],\n  end: ['start', 'center'],\n  center: ['end', 'start']\n};\nexport function getAnchoredPosition(floatingElement, anchorElement) {\n  let settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const parentElement = getPositionedParent(floatingElement);\n  const clippingRect = getClippingRect(parentElement);\n  const parentElementStyle = getComputedStyle(parentElement);\n  const parentElementRect = parentElement.getBoundingClientRect();\n  const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n  const relativeRect = {\n    top: parentElementRect.top + borderTop,\n    left: parentElementRect.left + borderLeft\n  };\n  return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\n\nfunction getPositionedParent(element) {\n  let parentNode = element.parentNode;\n\n  while (parentNode !== null) {\n    if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n      return parentNode;\n    }\n\n    parentNode = parentNode.parentNode;\n  }\n\n  return document.body;\n}\n\nfunction getClippingRect(element) {\n  let parentNode = element;\n\n  while (parentNode !== null) {\n    if (parentNode === document.body) {\n      break;\n    }\n\n    const parentNodeStyle = getComputedStyle(parentNode);\n\n    if (parentNodeStyle.overflow !== 'visible') {\n      break;\n    }\n\n    parentNode = parentNode.parentNode;\n  }\n\n  const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n  const elemRect = clippingNode.getBoundingClientRect();\n  const elemStyle = getComputedStyle(clippingNode);\n  const [borderTop, borderLeft, borderRight, borderBottom] = [elemStyle.borderTopWidth, elemStyle.borderLeftWidth, elemStyle.borderRightWidth, elemStyle.borderBottomWidth].map(v => parseInt(v, 10) || 0);\n  return {\n    top: elemRect.top + borderTop,\n    left: elemRect.left + borderLeft,\n    width: elemRect.width - borderRight - borderLeft,\n    height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity)\n  };\n}\n\nconst positionDefaults = {\n  side: 'outside-bottom',\n  align: 'start',\n  anchorOffset: 4,\n  alignmentOffset: 4,\n  allowOutOfBounds: false\n};\n\nfunction getDefaultSettings() {\n  let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _a, _b, _c, _d, _e;\n\n  const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n  const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n  return {\n    side,\n    align,\n    anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : side === 'inside-center' ? 0 : positionDefaults.anchorOffset,\n    alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0,\n    allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds\n  };\n}\n\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, _ref) {\n  let {\n    side,\n    align,\n    allowOutOfBounds,\n    anchorOffset,\n    alignmentOffset\n  } = _ref;\n  const relativeViewportRect = {\n    top: viewportRect.top - relativePosition.top,\n    left: viewportRect.left - relativePosition.left,\n    width: viewportRect.width,\n    height: viewportRect.height\n  };\n  let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n  let anchorSide = side;\n  let anchorAlign = align;\n  pos.top -= relativePosition.top;\n  pos.left -= relativePosition.left;\n\n  if (!allowOutOfBounds) {\n    const alternateOrder = alternateOrders[side];\n    let positionAttempt = 0;\n\n    if (alternateOrder) {\n      let prevSide = side;\n\n      while (positionAttempt < alternateOrder.length && shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n        const nextSide = alternateOrder[positionAttempt++];\n        prevSide = nextSide;\n        pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n        pos.top -= relativePosition.top;\n        pos.left -= relativePosition.left;\n        anchorSide = nextSide;\n      }\n    }\n\n    const alternateAlignment = alternateAlignments[align];\n    let alignmentAttempt = 0;\n\n    if (alternateAlignment) {\n      let prevAlign = align;\n\n      while (alignmentAttempt < alternateAlignment.length && shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n        const nextAlign = alternateAlignment[alignmentAttempt++];\n        prevAlign = nextAlign;\n        pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n        pos.top -= relativePosition.top;\n        pos.left -= relativePosition.left;\n        anchorAlign = nextAlign;\n      }\n    }\n\n    if (pos.top < relativeViewportRect.top) {\n      pos.top = relativeViewportRect.top;\n    }\n\n    if (pos.left < relativeViewportRect.left) {\n      pos.left = relativeViewportRect.left;\n    }\n\n    if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n      pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n    }\n\n    if (alternateOrder && positionAttempt < alternateOrder.length) {\n      if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n        pos.top = viewportRect.height + relativeViewportRect.top - floatingRect.height;\n      }\n    }\n  }\n\n  return Object.assign(Object.assign({}, pos), {\n    anchorSide,\n    anchorAlign\n  });\n}\n\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n  const anchorRight = anchorPosition.left + anchorPosition.width;\n  const anchorBottom = anchorPosition.top + anchorPosition.height;\n  let top = -1;\n  let left = -1;\n\n  if (side === 'outside-top') {\n    top = anchorPosition.top - anchorOffset - elementDimensions.height;\n  } else if (side === 'outside-bottom') {\n    top = anchorBottom + anchorOffset;\n  } else if (side === 'outside-left') {\n    left = anchorPosition.left - anchorOffset - elementDimensions.width;\n  } else if (side === 'outside-right') {\n    left = anchorRight + anchorOffset;\n  }\n\n  if (side === 'outside-top' || side === 'outside-bottom') {\n    if (align === 'start') {\n      left = anchorPosition.left + alignmentOffset;\n    } else if (align === 'center') {\n      left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n    } else {\n      left = anchorRight - elementDimensions.width - alignmentOffset;\n    }\n  }\n\n  if (side === 'outside-left' || side === 'outside-right') {\n    if (align === 'start') {\n      top = anchorPosition.top + alignmentOffset;\n    } else if (align === 'center') {\n      top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n    } else {\n      top = anchorBottom - elementDimensions.height - alignmentOffset;\n    }\n  }\n\n  if (side === 'inside-top') {\n    top = anchorPosition.top + anchorOffset;\n  } else if (side === 'inside-bottom') {\n    top = anchorBottom - anchorOffset - elementDimensions.height;\n  } else if (side === 'inside-left') {\n    left = anchorPosition.left + anchorOffset;\n  } else if (side === 'inside-right') {\n    left = anchorRight - anchorOffset - elementDimensions.width;\n  } else if (side === 'inside-center') {\n    left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n  }\n\n  if (side === 'inside-top' || side === 'inside-bottom') {\n    if (align === 'start') {\n      left = anchorPosition.left + alignmentOffset;\n    } else if (align === 'center') {\n      left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n    } else {\n      left = anchorRight - elementDimensions.width - alignmentOffset;\n    }\n  } else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n    if (align === 'start') {\n      top = anchorPosition.top + alignmentOffset;\n    } else if (align === 'center') {\n      top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n    } else {\n      top = anchorBottom - elementDimensions.height - alignmentOffset;\n    }\n  }\n\n  return {\n    top,\n    left\n  };\n}\n\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n  if (side === 'outside-top' || side === 'outside-bottom') {\n    return currentPos.top < containerDimensions.top || currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top;\n  } else {\n    return currentPos.left < containerDimensions.left || currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left;\n  }\n}\n\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n  if (align === 'end') {\n    return currentPos.left < containerDimensions.left;\n  } else if (align === 'start' || align === 'center') {\n    return currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width || currentPos.left < containerDimensions.left;\n  }\n}","map":{"version":3,"sources":["/Users/steve/Documents/repos/notifications/node_modules/@primer/behaviors/dist/esm/anchored-position.js"],"names":["alternateOrders","alternateAlignments","start","end","center","getAnchoredPosition","floatingElement","anchorElement","settings","parentElement","getPositionedParent","clippingRect","getClippingRect","parentElementStyle","getComputedStyle","parentElementRect","getBoundingClientRect","borderTop","borderLeft","borderTopWidth","borderLeftWidth","map","v","parseInt","relativeRect","top","left","pureCalculateAnchoredPosition","Element","getDefaultSettings","element","parentNode","HTMLElement","position","document","body","parentNodeStyle","overflow","clippingNode","elemRect","elemStyle","borderRight","borderBottom","borderRightWidth","borderBottomWidth","width","height","Math","max","window","innerHeight","Infinity","positionDefaults","side","align","anchorOffset","alignmentOffset","allowOutOfBounds","_a","_b","_c","_d","_e","startsWith","viewportRect","relativePosition","floatingRect","anchorRect","relativeViewportRect","pos","calculatePosition","anchorSide","anchorAlign","alternateOrder","positionAttempt","prevSide","length","shouldRecalculatePosition","nextSide","alternateAlignment","alignmentAttempt","prevAlign","shouldRecalculateAlignment","nextAlign","Object","assign","elementDimensions","anchorPosition","anchorRight","anchorBottom","currentPos","containerDimensions"],"mappings":"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","sourcesContent":["const alternateOrders = {\n    'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n    'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom']\n};\nconst alternateAlignments = {\n    start: ['end', 'center'],\n    end: ['start', 'center'],\n    center: ['end', 'start']\n};\nexport function getAnchoredPosition(floatingElement, anchorElement, settings = {}) {\n    const parentElement = getPositionedParent(floatingElement);\n    const clippingRect = getClippingRect(parentElement);\n    const parentElementStyle = getComputedStyle(parentElement);\n    const parentElementRect = parentElement.getBoundingClientRect();\n    const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n    const relativeRect = {\n        top: parentElementRect.top + borderTop,\n        left: parentElementRect.left + borderLeft\n    };\n    return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\nfunction getPositionedParent(element) {\n    let parentNode = element.parentNode;\n    while (parentNode !== null) {\n        if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n            return parentNode;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    return document.body;\n}\nfunction getClippingRect(element) {\n    let parentNode = element;\n    while (parentNode !== null) {\n        if (parentNode === document.body) {\n            break;\n        }\n        const parentNodeStyle = getComputedStyle(parentNode);\n        if (parentNodeStyle.overflow !== 'visible') {\n            break;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n    const elemRect = clippingNode.getBoundingClientRect();\n    const elemStyle = getComputedStyle(clippingNode);\n    const [borderTop, borderLeft, borderRight, borderBottom] = [\n        elemStyle.borderTopWidth,\n        elemStyle.borderLeftWidth,\n        elemStyle.borderRightWidth,\n        elemStyle.borderBottomWidth\n    ].map(v => parseInt(v, 10) || 0);\n    return {\n        top: elemRect.top + borderTop,\n        left: elemRect.left + borderLeft,\n        width: elemRect.width - borderRight - borderLeft,\n        height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity)\n    };\n}\nconst positionDefaults = {\n    side: 'outside-bottom',\n    align: 'start',\n    anchorOffset: 4,\n    alignmentOffset: 4,\n    allowOutOfBounds: false\n};\nfunction getDefaultSettings(settings = {}) {\n    var _a, _b, _c, _d, _e;\n    const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n    const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n    return {\n        side,\n        align,\n        anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : (side === 'inside-center' ? 0 : positionDefaults.anchorOffset),\n        alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : (align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0),\n        allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds\n    };\n}\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, { side, align, allowOutOfBounds, anchorOffset, alignmentOffset }) {\n    const relativeViewportRect = {\n        top: viewportRect.top - relativePosition.top,\n        left: viewportRect.left - relativePosition.left,\n        width: viewportRect.width,\n        height: viewportRect.height\n    };\n    let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n    let anchorSide = side;\n    let anchorAlign = align;\n    pos.top -= relativePosition.top;\n    pos.left -= relativePosition.left;\n    if (!allowOutOfBounds) {\n        const alternateOrder = alternateOrders[side];\n        let positionAttempt = 0;\n        if (alternateOrder) {\n            let prevSide = side;\n            while (positionAttempt < alternateOrder.length &&\n                shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n                const nextSide = alternateOrder[positionAttempt++];\n                prevSide = nextSide;\n                pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorSide = nextSide;\n            }\n        }\n        const alternateAlignment = alternateAlignments[align];\n        let alignmentAttempt = 0;\n        if (alternateAlignment) {\n            let prevAlign = align;\n            while (alignmentAttempt < alternateAlignment.length &&\n                shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n                const nextAlign = alternateAlignment[alignmentAttempt++];\n                prevAlign = nextAlign;\n                pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorAlign = nextAlign;\n            }\n        }\n        if (pos.top < relativeViewportRect.top) {\n            pos.top = relativeViewportRect.top;\n        }\n        if (pos.left < relativeViewportRect.left) {\n            pos.left = relativeViewportRect.left;\n        }\n        if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n            pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n        }\n        if (alternateOrder && positionAttempt < alternateOrder.length) {\n            if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n                pos.top = viewportRect.height + relativeViewportRect.top - floatingRect.height;\n            }\n        }\n    }\n    return Object.assign(Object.assign({}, pos), { anchorSide, anchorAlign });\n}\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n    const anchorRight = anchorPosition.left + anchorPosition.width;\n    const anchorBottom = anchorPosition.top + anchorPosition.height;\n    let top = -1;\n    let left = -1;\n    if (side === 'outside-top') {\n        top = anchorPosition.top - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'outside-bottom') {\n        top = anchorBottom + anchorOffset;\n    }\n    else if (side === 'outside-left') {\n        left = anchorPosition.left - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'outside-right') {\n        left = anchorRight + anchorOffset;\n    }\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    if (side === 'outside-left' || side === 'outside-right') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    if (side === 'inside-top') {\n        top = anchorPosition.top + anchorOffset;\n    }\n    else if (side === 'inside-bottom') {\n        top = anchorBottom - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'inside-left') {\n        left = anchorPosition.left + anchorOffset;\n    }\n    else if (side === 'inside-right') {\n        left = anchorRight - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'inside-center') {\n        left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n    }\n    if (side === 'inside-top' || side === 'inside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    return { top, left };\n}\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        return (currentPos.top < containerDimensions.top ||\n            currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top);\n    }\n    else {\n        return (currentPos.left < containerDimensions.left ||\n            currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left);\n    }\n}\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n    if (align === 'end') {\n        return currentPos.left < containerDimensions.left;\n    }\n    else if (align === 'start' || align === 'center') {\n        return (currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width ||\n            currentPos.left < containerDimensions.left);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n\n(function (FocusKeys) {\n  FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n  FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n  FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n  FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n  FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n  FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n  FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n  FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n  FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n  FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n  FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n  FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n  FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\n\nconst KEY_TO_BIT = {\n  ArrowLeft: FocusKeys.ArrowHorizontal,\n  ArrowDown: FocusKeys.ArrowVertical,\n  ArrowUp: FocusKeys.ArrowVertical,\n  ArrowRight: FocusKeys.ArrowHorizontal,\n  h: FocusKeys.HL,\n  j: FocusKeys.JK,\n  k: FocusKeys.JK,\n  l: FocusKeys.HL,\n  a: FocusKeys.AD,\n  s: FocusKeys.WS,\n  w: FocusKeys.WS,\n  d: FocusKeys.AD,\n  Tab: FocusKeys.Tab,\n  Home: FocusKeys.HomeAndEnd,\n  End: FocusKeys.HomeAndEnd,\n  PageUp: FocusKeys.PageUpDown,\n  PageDown: FocusKeys.PageUpDown\n};\nconst KEY_TO_DIRECTION = {\n  ArrowLeft: 'previous',\n  ArrowDown: 'next',\n  ArrowUp: 'previous',\n  ArrowRight: 'next',\n  h: 'previous',\n  j: 'next',\n  k: 'previous',\n  l: 'next',\n  a: 'previous',\n  s: 'next',\n  w: 'previous',\n  d: 'next',\n  Tab: 'next',\n  Home: 'start',\n  End: 'end',\n  PageUp: 'start',\n  PageDown: 'end'\n};\n\nfunction getDirection(keyboardEvent) {\n  const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n\n  if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n    return 'previous';\n  }\n\n  const isMac = isMacOS();\n\n  if (isMac && keyboardEvent.metaKey || !isMac && keyboardEvent.ctrlKey) {\n    if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n      return 'start';\n    } else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n      return 'end';\n    }\n  }\n\n  return direction;\n}\n\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n  const key = keyboardEvent.key;\n  const keyLength = [...key].length;\n  const isTextInput = activeElement instanceof HTMLInputElement && activeElement.type === 'text' || activeElement instanceof HTMLTextAreaElement;\n\n  if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n    return true;\n  }\n\n  if (activeElement instanceof HTMLSelectElement) {\n    if (keyLength === 1) {\n      return true;\n    }\n\n    if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n      return true;\n    }\n\n    if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n      return true;\n    }\n  }\n\n  if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n    return true;\n  }\n\n  if (isTextInput) {\n    const textInput = activeElement;\n    const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n    const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n\n    if (key === 'ArrowLeft' && !cursorAtStart) {\n      return true;\n    }\n\n    if (key === 'ArrowRight' && !cursorAtEnd) {\n      return true;\n    }\n\n    if (textInput instanceof HTMLTextAreaElement) {\n      if (key === 'ArrowUp' && !cursorAtStart) {\n        return true;\n      }\n\n      if (key === 'ArrowDown' && !cursorAtEnd) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n  var _a, _b, _c, _d;\n\n  const focusableElements = [];\n  const savedTabIndex = new WeakMap();\n  const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n  const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n  const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n  const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n  const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n  let currentFocusedElement;\n\n  function getFirstFocusableElement() {\n    return focusableElements[0];\n  }\n\n  function isActiveDescendantInputFocused() {\n    return document.activeElement === activeDescendantControl;\n  }\n\n  function updateFocusedElement(to) {\n    let directlyActivated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const from = currentFocusedElement;\n    currentFocusedElement = to;\n\n    if (activeDescendantControl) {\n      if (to && isActiveDescendantInputFocused()) {\n        setActiveDescendant(from, to, directlyActivated);\n      } else {\n        clearActiveDescendant();\n      }\n\n      return;\n    }\n\n    if (from && from !== to && savedTabIndex.has(from)) {\n      from.setAttribute('tabindex', '-1');\n    }\n\n    to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n  }\n\n  function setActiveDescendant(from, to) {\n    let directlyActivated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!to.id) {\n      to.setAttribute('id', uniqueId());\n    }\n\n    if (from && from !== to) {\n      from.removeAttribute(isActiveDescendantAttribute);\n    }\n\n    if (!activeDescendantControl || !directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id) {\n      return;\n    }\n\n    activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n    container.setAttribute(hasActiveDescendantAttribute, to.id);\n    to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n    activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n  }\n\n  function clearActiveDescendant() {\n    let previouslyActiveElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : currentFocusedElement;\n\n    if (focusInStrategy === 'first') {\n      currentFocusedElement = undefined;\n    }\n\n    activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n    container.removeAttribute(hasActiveDescendantAttribute);\n    previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n    activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n  }\n\n  function beginFocusManagement() {\n    for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) {\n      elements[_key] = arguments[_key];\n    }\n\n    const filteredElements = elements.filter(e => {\n      var _a, _b;\n\n      return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true;\n    });\n\n    if (filteredElements.length === 0) {\n      return;\n    }\n\n    const insertIndex = focusableElements.findIndex(e => (e.compareDocumentPosition(filteredElements[0]) & Node.DOCUMENT_POSITION_PRECEDING) > 0);\n    focusableElements.splice(insertIndex === -1 ? focusableElements.length : insertIndex, 0, ...filteredElements);\n\n    for (const element of filteredElements) {\n      if (!savedTabIndex.has(element)) {\n        savedTabIndex.set(element, element.getAttribute('tabindex'));\n      }\n\n      element.setAttribute('tabindex', '-1');\n    }\n\n    if (!currentFocusedElement) {\n      updateFocusedElement(getFirstFocusableElement());\n    }\n  }\n\n  function endFocusManagement() {\n    for (var _len2 = arguments.length, elements = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      elements[_key2] = arguments[_key2];\n    }\n\n    for (const element of elements) {\n      const focusableElementIndex = focusableElements.indexOf(element);\n\n      if (focusableElementIndex >= 0) {\n        focusableElements.splice(focusableElementIndex, 1);\n      }\n\n      const savedIndex = savedTabIndex.get(element);\n\n      if (savedIndex !== undefined) {\n        if (savedIndex === null) {\n          element.removeAttribute('tabindex');\n        } else {\n          element.setAttribute('tabindex', savedIndex);\n        }\n\n        savedTabIndex.delete(element);\n      }\n\n      if (element === currentFocusedElement) {\n        const nextElementToFocus = getFirstFocusableElement();\n        updateFocusedElement(nextElementToFocus);\n      }\n    }\n  }\n\n  beginFocusManagement(...iterateFocusableElements(container));\n  updateFocusedElement(getFirstFocusableElement());\n  const observer = new MutationObserver(mutations => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode instanceof HTMLElement) {\n          endFocusManagement(...iterateFocusableElements(removedNode));\n        }\n      }\n    }\n\n    for (const mutation of mutations) {\n      for (const addedNode of mutation.addedNodes) {\n        if (addedNode instanceof HTMLElement) {\n          beginFocusManagement(...iterateFocusableElements(addedNode));\n        }\n      }\n    }\n  });\n  observer.observe(container, {\n    subtree: true,\n    childList: true\n  });\n  const controller = new AbortController();\n  const signal = (_d = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _d !== void 0 ? _d : controller.signal;\n  signal.addEventListener('abort', () => {\n    endFocusManagement(...focusableElements);\n  });\n  let elementIndexFocusedByClick = undefined;\n  container.addEventListener('mousedown', event => {\n    if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n      elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n    }\n  }, {\n    signal\n  });\n\n  if (activeDescendantControl) {\n    container.addEventListener('focusin', event => {\n      if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n        activeDescendantControl.focus();\n        updateFocusedElement(event.target);\n      }\n    });\n    container.addEventListener('mousemove', _ref => {\n      let {\n        target\n      } = _ref;\n\n      if (!(target instanceof Node)) {\n        return;\n      }\n\n      const focusableElement = focusableElements.find(element => element.contains(target));\n\n      if (focusableElement) {\n        updateFocusedElement(focusableElement);\n      }\n    }, {\n      signal,\n      capture: true\n    });\n    activeDescendantControl.addEventListener('focusin', () => {\n      if (!currentFocusedElement) {\n        updateFocusedElement(getFirstFocusableElement());\n      } else {\n        setActiveDescendant(undefined, currentFocusedElement);\n      }\n    });\n    activeDescendantControl.addEventListener('focusout', () => {\n      clearActiveDescendant();\n    });\n  } else {\n    container.addEventListener('focusin', event => {\n      if (event.target instanceof HTMLElement) {\n        if (elementIndexFocusedByClick !== undefined) {\n          if (elementIndexFocusedByClick >= 0) {\n            if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n              updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n            }\n          }\n\n          elementIndexFocusedByClick = undefined;\n        } else {\n          if (focusInStrategy === 'previous') {\n            updateFocusedElement(event.target);\n          } else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n            if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n              const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n              const targetElement = focusableElements[targetElementIndex];\n              targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus();\n              return;\n            } else {\n              updateFocusedElement(event.target);\n            }\n          } else if (typeof focusInStrategy === 'function') {\n            if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n              const elementToFocus = focusInStrategy(event.relatedTarget);\n              const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n\n              if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                elementToFocus.focus();\n                return;\n              } else {\n                console.warn('Element requested is not a known focusable element.');\n              }\n            } else {\n              updateFocusedElement(event.target);\n            }\n          }\n        }\n      }\n\n      lastKeyboardFocusDirection = undefined;\n    }, {\n      signal\n    });\n  }\n\n  const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n  let lastKeyboardFocusDirection = undefined;\n\n  if (focusInStrategy === 'closest') {\n    document.addEventListener('keydown', event => {\n      if (event.key === 'Tab') {\n        lastKeyboardFocusDirection = getDirection(event);\n      }\n    }, {\n      signal,\n      capture: true\n    });\n  }\n\n  function getCurrentFocusedIndex() {\n    if (!currentFocusedElement) {\n      return 0;\n    }\n\n    const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n    const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n    return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n  }\n\n  keyboardEventRecipient.addEventListener('keydown', event => {\n    var _a;\n\n    if (event.key in KEY_TO_DIRECTION) {\n      const keyBit = KEY_TO_BIT[event.key];\n\n      if (!event.defaultPrevented && (keyBit & bindKeys) > 0 && !shouldIgnoreFocusHandling(event, document.activeElement)) {\n        const direction = getDirection(event);\n        let nextElementToFocus = undefined;\n\n        if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n          nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n        }\n\n        if (!nextElementToFocus) {\n          const lastFocusedIndex = getCurrentFocusedIndex();\n          let nextFocusedIndex = lastFocusedIndex;\n\n          if (direction === 'previous') {\n            nextFocusedIndex -= 1;\n          } else if (direction === 'start') {\n            nextFocusedIndex = 0;\n          } else if (direction === 'next') {\n            nextFocusedIndex += 1;\n          } else {\n            nextFocusedIndex = focusableElements.length - 1;\n          }\n\n          if (nextFocusedIndex < 0) {\n            if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n              nextFocusedIndex = focusableElements.length - 1;\n            } else {\n              nextFocusedIndex = 0;\n            }\n          }\n\n          if (nextFocusedIndex >= focusableElements.length) {\n            if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n              nextFocusedIndex = 0;\n            } else {\n              nextFocusedIndex = focusableElements.length - 1;\n            }\n          }\n\n          if (lastFocusedIndex !== nextFocusedIndex) {\n            nextElementToFocus = focusableElements[nextFocusedIndex];\n          }\n        }\n\n        if (activeDescendantControl) {\n          updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n        } else if (nextElementToFocus) {\n          lastKeyboardFocusDirection = direction;\n          nextElementToFocus.focus();\n        }\n\n        if (event.key !== 'Tab' || nextElementToFocus) {\n          event.preventDefault();\n        }\n      }\n    }\n  }, {\n    signal\n  });\n  return controller;\n}","map":{"version":3,"sources":["/Users/steve/Documents/repos/github-notifications/node_modules/@primer/behaviors/dist/esm/focus-zone.js"],"names":["polyfill","eventListenerSignalPolyfill","isMacOS","iterateFocusableElements","uniqueId","FocusKeys","KEY_TO_BIT","ArrowLeft","ArrowHorizontal","ArrowDown","ArrowVertical","ArrowUp","ArrowRight","h","HL","j","JK","k","l","a","AD","s","WS","w","d","Tab","Home","HomeAndEnd","End","PageUp","PageUpDown","PageDown","KEY_TO_DIRECTION","getDirection","keyboardEvent","direction","key","shiftKey","isMac","metaKey","ctrlKey","shouldIgnoreFocusHandling","activeElement","keyLength","length","isTextInput","HTMLInputElement","type","HTMLTextAreaElement","HTMLSelectElement","altKey","textInput","cursorAtStart","selectionStart","selectionEnd","cursorAtEnd","value","isActiveDescendantAttribute","activeDescendantActivatedDirectly","activeDescendantActivatedIndirectly","hasActiveDescendantAttribute","focusZone","container","settings","_a","_b","_c","_d","focusableElements","savedTabIndex","WeakMap","bindKeys","getNextFocusable","ArrowAll","focusOutBehavior","focusInStrategy","activeDescendantControl","activeDescendantCallback","onActiveDescendantChanged","currentFocusedElement","getFirstFocusableElement","isActiveDescendantInputFocused","document","updateFocusedElement","to","directlyActivated","from","setActiveDescendant","clearActiveDescendant","has","setAttribute","id","removeAttribute","getAttribute","previouslyActiveElement","undefined","beginFocusManagement","elements","filteredElements","filter","e","focusableElementFilter","call","insertIndex","findIndex","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","splice","element","set","endFocusManagement","focusableElementIndex","indexOf","savedIndex","get","delete","nextElementToFocus","observer","MutationObserver","mutations","mutation","removedNode","removedNodes","HTMLElement","addedNode","addedNodes","observe","subtree","childList","controller","AbortController","signal","abortSignal","addEventListener","elementIndexFocusedByClick","event","target","includes","focus","focusableElement","find","contains","capture","relatedTarget","Element","targetElementIndex","lastKeyboardFocusDirection","targetElement","elementToFocus","requestedFocusElementIndex","console","warn","keyboardEventRecipient","getCurrentFocusedIndex","focusedIndex","fallbackIndex","keyBit","defaultPrevented","lastFocusedIndex","nextFocusedIndex","preventDefault"],"mappings":"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","sourcesContent":["import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n(function (FocusKeys) {\n    FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n    FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n    FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n    FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n    FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n    FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n    FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n    FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n    FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n    FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n    FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n    FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n    FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n    ArrowLeft: FocusKeys.ArrowHorizontal,\n    ArrowDown: FocusKeys.ArrowVertical,\n    ArrowUp: FocusKeys.ArrowVertical,\n    ArrowRight: FocusKeys.ArrowHorizontal,\n    h: FocusKeys.HL,\n    j: FocusKeys.JK,\n    k: FocusKeys.JK,\n    l: FocusKeys.HL,\n    a: FocusKeys.AD,\n    s: FocusKeys.WS,\n    w: FocusKeys.WS,\n    d: FocusKeys.AD,\n    Tab: FocusKeys.Tab,\n    Home: FocusKeys.HomeAndEnd,\n    End: FocusKeys.HomeAndEnd,\n    PageUp: FocusKeys.PageUpDown,\n    PageDown: FocusKeys.PageUpDown\n};\nconst KEY_TO_DIRECTION = {\n    ArrowLeft: 'previous',\n    ArrowDown: 'next',\n    ArrowUp: 'previous',\n    ArrowRight: 'next',\n    h: 'previous',\n    j: 'next',\n    k: 'previous',\n    l: 'next',\n    a: 'previous',\n    s: 'next',\n    w: 'previous',\n    d: 'next',\n    Tab: 'next',\n    Home: 'start',\n    End: 'end',\n    PageUp: 'start',\n    PageDown: 'end'\n};\nfunction getDirection(keyboardEvent) {\n    const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n    if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n        return 'previous';\n    }\n    const isMac = isMacOS();\n    if ((isMac && keyboardEvent.metaKey) || (!isMac && keyboardEvent.ctrlKey)) {\n        if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n            return 'start';\n        }\n        else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n            return 'end';\n        }\n    }\n    return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n    const key = keyboardEvent.key;\n    const keyLength = [...key].length;\n    const isTextInput = (activeElement instanceof HTMLInputElement && activeElement.type === 'text') ||\n        activeElement instanceof HTMLTextAreaElement;\n    if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n        return true;\n    }\n    if (activeElement instanceof HTMLSelectElement) {\n        if (keyLength === 1) {\n            return true;\n        }\n        if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n            return true;\n        }\n        if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n            return true;\n        }\n    }\n    if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n        return true;\n    }\n    if (isTextInput) {\n        const textInput = activeElement;\n        const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n        const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n        if (key === 'ArrowLeft' && !cursorAtStart) {\n            return true;\n        }\n        if (key === 'ArrowRight' && !cursorAtEnd) {\n            return true;\n        }\n        if (textInput instanceof HTMLTextAreaElement) {\n            if (key === 'ArrowUp' && !cursorAtStart) {\n                return true;\n            }\n            if (key === 'ArrowDown' && !cursorAtEnd) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n    var _a, _b, _c, _d;\n    const focusableElements = [];\n    const savedTabIndex = new WeakMap();\n    const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n    const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n    const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n    const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n    const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n    let currentFocusedElement;\n    function getFirstFocusableElement() {\n        return focusableElements[0];\n    }\n    function isActiveDescendantInputFocused() {\n        return document.activeElement === activeDescendantControl;\n    }\n    function updateFocusedElement(to, directlyActivated = false) {\n        const from = currentFocusedElement;\n        currentFocusedElement = to;\n        if (activeDescendantControl) {\n            if (to && isActiveDescendantInputFocused()) {\n                setActiveDescendant(from, to, directlyActivated);\n            }\n            else {\n                clearActiveDescendant();\n            }\n            return;\n        }\n        if (from && from !== to && savedTabIndex.has(from)) {\n            from.setAttribute('tabindex', '-1');\n        }\n        to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n    }\n    function setActiveDescendant(from, to, directlyActivated = false) {\n        if (!to.id) {\n            to.setAttribute('id', uniqueId());\n        }\n        if (from && from !== to) {\n            from.removeAttribute(isActiveDescendantAttribute);\n        }\n        if (!activeDescendantControl ||\n            (!directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id)) {\n            return;\n        }\n        activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n        container.setAttribute(hasActiveDescendantAttribute, to.id);\n        to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n    }\n    function clearActiveDescendant(previouslyActiveElement = currentFocusedElement) {\n        if (focusInStrategy === 'first') {\n            currentFocusedElement = undefined;\n        }\n        activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n        container.removeAttribute(hasActiveDescendantAttribute);\n        previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n    }\n    function beginFocusManagement(...elements) {\n        const filteredElements = elements.filter(e => { var _a, _b; return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true; });\n        if (filteredElements.length === 0) {\n            return;\n        }\n        const insertIndex = focusableElements.findIndex(e => (e.compareDocumentPosition(filteredElements[0]) & Node.DOCUMENT_POSITION_PRECEDING) > 0);\n        focusableElements.splice(insertIndex === -1 ? focusableElements.length : insertIndex, 0, ...filteredElements);\n        for (const element of filteredElements) {\n            if (!savedTabIndex.has(element)) {\n                savedTabIndex.set(element, element.getAttribute('tabindex'));\n            }\n            element.setAttribute('tabindex', '-1');\n        }\n        if (!currentFocusedElement) {\n            updateFocusedElement(getFirstFocusableElement());\n        }\n    }\n    function endFocusManagement(...elements) {\n        for (const element of elements) {\n            const focusableElementIndex = focusableElements.indexOf(element);\n            if (focusableElementIndex >= 0) {\n                focusableElements.splice(focusableElementIndex, 1);\n            }\n            const savedIndex = savedTabIndex.get(element);\n            if (savedIndex !== undefined) {\n                if (savedIndex === null) {\n                    element.removeAttribute('tabindex');\n                }\n                else {\n                    element.setAttribute('tabindex', savedIndex);\n                }\n                savedTabIndex.delete(element);\n            }\n            if (element === currentFocusedElement) {\n                const nextElementToFocus = getFirstFocusableElement();\n                updateFocusedElement(nextElementToFocus);\n            }\n        }\n    }\n    beginFocusManagement(...iterateFocusableElements(container));\n    updateFocusedElement(getFirstFocusableElement());\n    const observer = new MutationObserver(mutations => {\n        for (const mutation of mutations) {\n            for (const removedNode of mutation.removedNodes) {\n                if (removedNode instanceof HTMLElement) {\n                    endFocusManagement(...iterateFocusableElements(removedNode));\n                }\n            }\n        }\n        for (const mutation of mutations) {\n            for (const addedNode of mutation.addedNodes) {\n                if (addedNode instanceof HTMLElement) {\n                    beginFocusManagement(...iterateFocusableElements(addedNode));\n                }\n            }\n        }\n    });\n    observer.observe(container, {\n        subtree: true,\n        childList: true\n    });\n    const controller = new AbortController();\n    const signal = (_d = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _d !== void 0 ? _d : controller.signal;\n    signal.addEventListener('abort', () => {\n        endFocusManagement(...focusableElements);\n    });\n    let elementIndexFocusedByClick = undefined;\n    container.addEventListener('mousedown', event => {\n        if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n            elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n        }\n    }, { signal });\n    if (activeDescendantControl) {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n                activeDescendantControl.focus();\n                updateFocusedElement(event.target);\n            }\n        });\n        container.addEventListener('mousemove', ({ target }) => {\n            if (!(target instanceof Node)) {\n                return;\n            }\n            const focusableElement = focusableElements.find(element => element.contains(target));\n            if (focusableElement) {\n                updateFocusedElement(focusableElement);\n            }\n        }, { signal, capture: true });\n        activeDescendantControl.addEventListener('focusin', () => {\n            if (!currentFocusedElement) {\n                updateFocusedElement(getFirstFocusableElement());\n            }\n            else {\n                setActiveDescendant(undefined, currentFocusedElement);\n            }\n        });\n        activeDescendantControl.addEventListener('focusout', () => {\n            clearActiveDescendant();\n        });\n    }\n    else {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement) {\n                if (elementIndexFocusedByClick !== undefined) {\n                    if (elementIndexFocusedByClick >= 0) {\n                        if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n                            updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n                        }\n                    }\n                    elementIndexFocusedByClick = undefined;\n                }\n                else {\n                    if (focusInStrategy === 'previous') {\n                        updateFocusedElement(event.target);\n                    }\n                    else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n                            const targetElement = focusableElements[targetElementIndex];\n                            targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus();\n                            return;\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                    else if (typeof focusInStrategy === 'function') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const elementToFocus = focusInStrategy(event.relatedTarget);\n                            const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n                            if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                                elementToFocus.focus();\n                                return;\n                            }\n                            else {\n                                console.warn('Element requested is not a known focusable element.');\n                            }\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                }\n            }\n            lastKeyboardFocusDirection = undefined;\n        }, { signal });\n    }\n    const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n    let lastKeyboardFocusDirection = undefined;\n    if (focusInStrategy === 'closest') {\n        document.addEventListener('keydown', event => {\n            if (event.key === 'Tab') {\n                lastKeyboardFocusDirection = getDirection(event);\n            }\n        }, { signal, capture: true });\n    }\n    function getCurrentFocusedIndex() {\n        if (!currentFocusedElement) {\n            return 0;\n        }\n        const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n        const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n        return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n    }\n    keyboardEventRecipient.addEventListener('keydown', event => {\n        var _a;\n        if (event.key in KEY_TO_DIRECTION) {\n            const keyBit = KEY_TO_BIT[event.key];\n            if (!event.defaultPrevented &&\n                (keyBit & bindKeys) > 0 &&\n                !shouldIgnoreFocusHandling(event, document.activeElement)) {\n                const direction = getDirection(event);\n                let nextElementToFocus = undefined;\n                if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n                    nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n                }\n                if (!nextElementToFocus) {\n                    const lastFocusedIndex = getCurrentFocusedIndex();\n                    let nextFocusedIndex = lastFocusedIndex;\n                    if (direction === 'previous') {\n                        nextFocusedIndex -= 1;\n                    }\n                    else if (direction === 'start') {\n                        nextFocusedIndex = 0;\n                    }\n                    else if (direction === 'next') {\n                        nextFocusedIndex += 1;\n                    }\n                    else {\n                        nextFocusedIndex = focusableElements.length - 1;\n                    }\n                    if (nextFocusedIndex < 0) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                        else {\n                            nextFocusedIndex = 0;\n                        }\n                    }\n                    if (nextFocusedIndex >= focusableElements.length) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = 0;\n                        }\n                        else {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                    }\n                    if (lastFocusedIndex !== nextFocusedIndex) {\n                        nextElementToFocus = focusableElements[nextFocusedIndex];\n                    }\n                }\n                if (activeDescendantControl) {\n                    updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n                }\n                else if (nextElementToFocus) {\n                    lastKeyboardFocusDirection = direction;\n                    nextElementToFocus.focus();\n                }\n                if (event.key !== 'Tab' || nextElementToFocus) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, { signal });\n    return controller;\n}\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/**\n * @module store\n *\n */\n\n\nimport matchKeys from './lib/match_keys';\nimport parseKeys from './lib/parse_keys';\nimport uuid from './lib/uuid';\n/**\n * private\n *\n */\n// dict for class prototypes => bindings\n\nvar _handlers = new Map(); // all mounted instances that have keybindings\n\n\nvar _instances = new Set(); // for testing\n\n\nexport function _resetStore() {\n  _handlers.clear();\n\n  _instances.clear();\n}\n/**\n * activate\n *\n * @access public\n * @param {object} instance Instantiated class that extended React.Component, to be focused to receive keydown events\n */\n\nexport function activate(instances) {\n  var instancesArray = [].concat(instances); // if no components were found as ancestors of the event target,\n  // effectively deactivate keydown handling by capping the set of instances\n  // with `null`.\n\n  if (!instancesArray.length) {\n    _instances.add(null);\n  } else {\n    _instances.delete(null); // deleting and then adding the instance(s) has the effect of sorting the set\n    // according to instance activation (ascending)\n\n\n    instancesArray.forEach(function (instance) {\n      _instances.delete(instance);\n\n      _instances.add(instance);\n    });\n  }\n}\n;\n/**\n * deleteInstance\n *\n * @access public\n * @param {object} target Instantiated class that extended React.Component\n * @return {boolean} The value set.has( target ) would have returned prior to deletion\n */\n\nexport function deleteInstance(target) {\n  _instances.delete(target);\n}\n;\nexport function findBindingForEvent(event) {\n  if (!_instances.has(null)) {\n    var keyMatchesEvent = function keyMatchesEvent(keySet) {\n      return matchKeys({\n        keySet: keySet,\n        event: event\n      });\n    }; // loop through instances in reverse activation order so that most\n    // recently activated instance gets first dibs on event\n\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = [].concat(_toConsumableArray(_instances)).reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var instance = _step.value;\n        var bindings = getBinding(instance.constructor.prototype);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = bindings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                keySets = _step2$value[0],\n                fn = _step2$value[1];\n\n            if (keySets.some(keyMatchesEvent)) {\n              // return when matching keybinding is found - i.e. only one\n              // keybound component can respond to a given key code. to get around this,\n              // scope a common ancestor component class with @keydown and use\n              // @keydownScoped to bind the duplicate keys in your child components\n              // (or just inspect nextProps.keydown.event).\n              return {\n                fn: fn,\n                instance: instance\n              };\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n;\n/**\n * getBinding\n *\n * @access public\n * @param {object} target Class used as key in dict of key bindings\n * @return {object} The object containing bindings for the given class\n */\n\nexport function getBinding(_ref) {\n  var __reactKeydownUUID = _ref.__reactKeydownUUID;\n  return _handlers.get(__reactKeydownUUID);\n}\n;\n/**\n * getInstances\n *\n * @access public\n * @return {set} All stored instances (all mounted component instances with keybindings)\n */\n\nexport function getInstances() {\n  return _instances;\n}\n;\n/**\n * isEmpty\n *\n * @access public\n * @return {number} Size of the set of all stored instances\n */\n\nexport function isEmpty() {\n  return !_instances.size;\n}\n;\n/**\n * setBinding\n *\n * @access public\n * @param {object} args All arguments necessary to set the binding\n * @param {array} args.keys Key codes that should trigger the fn\n * @param {function} args.fn The callback to be triggered when given keys are pressed\n * @param {object} args.target The decorated class\n */\n\nexport function setBinding(_ref2) {\n  var keys = _ref2.keys,\n      fn = _ref2.fn,\n      target = _ref2.target;\n  var keySets = parseKeys(keys);\n  var __reactKeydownUUID = target.__reactKeydownUUID;\n\n  if (!__reactKeydownUUID) {\n    target.__reactKeydownUUID = uuid();\n\n    _handlers.set(target.__reactKeydownUUID, new Map([[keySets, fn]]));\n  } else {\n    _handlers.get(__reactKeydownUUID).set(keySets, fn);\n  }\n}\n;","map":{"version":3,"sources":["/Users/steve/Documents/repos/github-notifications/node_modules/react-keydown/es/store.js"],"names":["_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","length","err","Array","isArray","Object","TypeError","_toConsumableArray","arr2","from","matchKeys","parseKeys","uuid","_handlers","Map","_instances","Set","_resetStore","clear","activate","instances","instancesArray","concat","add","delete","forEach","instance","deleteInstance","target","findBindingForEvent","event","has","keyMatchesEvent","keySet","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_iterator","reverse","_step","bindings","getBinding","constructor","prototype","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_step2$value","keySets","fn","some","return","_ref","__reactKeydownUUID","get","getInstances","isEmpty","size","setBinding","_ref2","keys","set"],"mappings":"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","sourcesContent":["var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * @module store\n *\n */\nimport matchKeys from './lib/match_keys';\nimport parseKeys from './lib/parse_keys';\nimport uuid from './lib/uuid';\n\n/**\n * private\n *\n */\n\n// dict for class prototypes => bindings\nvar _handlers = new Map();\n\n// all mounted instances that have keybindings\nvar _instances = new Set();\n\n// for testing\nexport function _resetStore() {\n  _handlers.clear();\n  _instances.clear();\n}\n\n/**\n * activate\n *\n * @access public\n * @param {object} instance Instantiated class that extended React.Component, to be focused to receive keydown events\n */\nexport function activate(instances) {\n  var instancesArray = [].concat(instances);\n\n  // if no components were found as ancestors of the event target,\n  // effectively deactivate keydown handling by capping the set of instances\n  // with `null`.\n  if (!instancesArray.length) {\n    _instances.add(null);\n  } else {\n    _instances.delete(null);\n\n    // deleting and then adding the instance(s) has the effect of sorting the set\n    // according to instance activation (ascending)\n    instancesArray.forEach(function (instance) {\n      _instances.delete(instance);\n      _instances.add(instance);\n    });\n  }\n};\n\n/**\n * deleteInstance\n *\n * @access public\n * @param {object} target Instantiated class that extended React.Component\n * @return {boolean} The value set.has( target ) would have returned prior to deletion\n */\nexport function deleteInstance(target) {\n  _instances.delete(target);\n};\n\nexport function findBindingForEvent(event) {\n  if (!_instances.has(null)) {\n    var keyMatchesEvent = function keyMatchesEvent(keySet) {\n      return matchKeys({ keySet: keySet, event: event });\n    };\n\n    // loop through instances in reverse activation order so that most\n    // recently activated instance gets first dibs on event\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = [].concat(_toConsumableArray(_instances)).reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var instance = _step.value;\n\n        var bindings = getBinding(instance.constructor.prototype);\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = bindings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n                keySets = _step2$value[0],\n                fn = _step2$value[1];\n\n            if (keySets.some(keyMatchesEvent)) {\n              // return when matching keybinding is found - i.e. only one\n              // keybound component can respond to a given key code. to get around this,\n              // scope a common ancestor component class with @keydown and use\n              // @keydownScoped to bind the duplicate keys in your child components\n              // (or just inspect nextProps.keydown.event).\n              return { fn: fn, instance: instance };\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * getBinding\n *\n * @access public\n * @param {object} target Class used as key in dict of key bindings\n * @return {object} The object containing bindings for the given class\n */\nexport function getBinding(_ref) {\n  var __reactKeydownUUID = _ref.__reactKeydownUUID;\n\n  return _handlers.get(__reactKeydownUUID);\n};\n\n/**\n * getInstances\n *\n * @access public\n * @return {set} All stored instances (all mounted component instances with keybindings)\n */\nexport function getInstances() {\n  return _instances;\n};\n\n/**\n * isEmpty\n *\n * @access public\n * @return {number} Size of the set of all stored instances\n */\nexport function isEmpty() {\n  return !_instances.size;\n};\n\n/**\n * setBinding\n *\n * @access public\n * @param {object} args All arguments necessary to set the binding\n * @param {array} args.keys Key codes that should trigger the fn\n * @param {function} args.fn The callback to be triggered when given keys are pressed\n * @param {object} args.target The decorated class\n */\nexport function setBinding(_ref2) {\n  var keys = _ref2.keys,\n      fn = _ref2.fn,\n      target = _ref2.target;\n\n  var keySets = parseKeys(keys);\n\n  var __reactKeydownUUID = target.__reactKeydownUUID;\n\n  if (!__reactKeydownUUID) {\n    target.__reactKeydownUUID = uuid();\n    _handlers.set(target.__reactKeydownUUID, new Map([[keySets, fn]]));\n  } else {\n    _handlers.get(__reactKeydownUUID).set(keySets, fn);\n  }\n};"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"export function* iterateFocusableElements(container) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a, _b;\n\n  const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n  const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n  });\n  let nextNode = null;\n\n  if (!options.reverse && acceptFn(container, strict)) {\n    yield container;\n  }\n\n  if (options.reverse) {\n    let lastChild = walker.lastChild();\n\n    while (lastChild) {\n      nextNode = lastChild;\n      lastChild = walker.lastChild();\n    }\n  } else {\n    nextNode = walker.firstChild();\n  }\n\n  while (nextNode instanceof HTMLElement) {\n    yield nextNode;\n    nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n  }\n\n  if (options.reverse && acceptFn(container, strict)) {\n    yield container;\n  }\n\n  return undefined;\n}\nexport function getFocusableChild(container) {\n  let lastChild = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return iterateFocusableElements(container, {\n    reverse: lastChild,\n    strict: true,\n    onlyTabbable: true\n  }).next().value;\n}\nexport function isFocusable(elem) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) && elem.disabled;\n  const hiddenInert = elem.hidden;\n  const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n  const sentinelInert = elem.classList.contains('sentinel');\n\n  if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n    return false;\n  }\n\n  if (strict) {\n    const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n    const visibilityInert = ['hidden', 'collapse'].includes(getComputedStyle(elem).visibility);\n    const clientRectsInert = elem.getClientRects().length === 0;\n\n    if (sizeInert || visibilityInert || clientRectsInert) {\n      return false;\n    }\n  }\n\n  if (elem.getAttribute('tabindex') != null) {\n    return true;\n  }\n\n  if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n    return false;\n  }\n\n  return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem) {\n  let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}","map":{"version":3,"sources":["/Users/steve/Documents/repos/github-notifications/node_modules/@primer/behaviors/dist/esm/utils/iterate-focusable-elements.js"],"names":["iterateFocusableElements","container","options","_a","_b","strict","acceptFn","onlyTabbable","isTabbable","isFocusable","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","HTMLElement","FILTER_ACCEPT","FILTER_SKIP","nextNode","reverse","lastChild","firstChild","previousNode","undefined","getFocusableChild","next","value","elem","disabledAttrInert","includes","tagName","disabled","hiddenInert","hidden","hiddenInputInert","HTMLInputElement","type","sentinelInert","classList","contains","sizeInert","offsetWidth","offsetHeight","visibilityInert","getComputedStyle","visibility","clientRectsInert","getClientRects","length","getAttribute","HTMLAnchorElement","tabIndex"],"mappings":"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","sourcesContent":["export function* iterateFocusableElements(container, options = {}) {\n    var _a, _b;\n    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n    const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP\n    });\n    let nextNode = null;\n    if (!options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    if (options.reverse) {\n        let lastChild = walker.lastChild();\n        while (lastChild) {\n            nextNode = lastChild;\n            lastChild = walker.lastChild();\n        }\n    }\n    else {\n        nextNode = walker.firstChild();\n    }\n    while (nextNode instanceof HTMLElement) {\n        yield nextNode;\n        nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n    }\n    if (options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    return undefined;\n}\nexport function getFocusableChild(container, lastChild = false) {\n    return iterateFocusableElements(container, { reverse: lastChild, strict: true, onlyTabbable: true }).next().value;\n}\nexport function isFocusable(elem, strict = false) {\n    const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) &&\n        elem.disabled;\n    const hiddenInert = elem.hidden;\n    const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n    const sentinelInert = elem.classList.contains('sentinel');\n    if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n        return false;\n    }\n    if (strict) {\n        const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n        const visibilityInert = ['hidden', 'collapse'].includes(getComputedStyle(elem).visibility);\n        const clientRectsInert = elem.getClientRects().length === 0;\n        if (sizeInert || visibilityInert || clientRectsInert) {\n            return false;\n        }\n    }\n    if (elem.getAttribute('tabindex') != null) {\n        return true;\n    }\n    if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n        return false;\n    }\n    return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem, strict = false) {\n    return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}\n"]},"metadata":{},"sourceType":"module"}
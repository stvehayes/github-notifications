{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport { FocusKeys } from '@primer/behaviors';\nimport { isFocusable } from '@primer/behaviors/utils';\nimport { omit } from '@styled-system/props';\nimport React, { useRef, useState } from 'react';\nimport Box from './Box';\nimport { useProvidedRefOrCreate } from './hooks';\nimport { useCombinedRefs } from './hooks/useCombinedRefs';\nimport { useFocusZone } from './hooks/useFocusZone';\nimport Text from './Text';\nimport Token from './Token/Token';\nimport TextInputInnerVisualSlot from './_TextInputInnerVisualSlot';\nimport TextInputWrapper, { textInputHorizPadding } from './_TextInputWrapper';\nimport UnstyledTextInput from './_UnstyledTextInput'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  extralarge: 2,\n  xlarge: 2 // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n\n}; // using forwardRef is important so that other components (ex. Autocomplete) can use the ref\n\nfunction TextInputWithTokensInnerComponent(_ref, externalRef) {\n  let {\n    icon: IconComponent,\n    leadingVisual: LeadingVisual,\n    trailingVisual: TrailingVisual,\n    loading,\n    loaderPosition,\n    contrast,\n    className,\n    block,\n    disabled,\n    sx: sxProp,\n    tokens,\n    onTokenRemove,\n    tokenComponent: TokenComponent,\n    preventTokenWrapping,\n    size,\n    hideTokenRemoveButtons,\n    maxHeight,\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    validationStatus,\n    variant: variantProp,\n    // deprecated. use `size` instead\n    visibleTokenCount,\n    ...rest\n  } = _ref;\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useProvidedRefOrCreate(externalRef);\n  const localInputRef = useRef(null);\n  const combinedInputRef = useCombinedRefs(localInputRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return combinedInputRef.current || undefined;\n      }\n\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId); // HACK: wait a tick for the token node to be removed from the DOM\n\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0]; // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current; // if there are no tokens left, focus the input\n\n\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n\n  const handleTokenFocus = tokenIndex => () => {\n    setSelectedTokenIndex(tokenIndex);\n  };\n\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current4;\n\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n\n  const handleInputBlur = event => {\n    onBlur && onBlur(event); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current5;\n\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n\n    const lastToken = tokens[tokens.length - 1];\n\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      } // HACK: for some reason we need to wait a tick for `.select()` to work\n\n\n      setTimeout(() => {\n        var _ref$current4;\n\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n\n  const focusInput = () => {\n    var _combinedInputRef$cur;\n\n    (_combinedInputRef$cur = combinedInputRef.current) === null || _combinedInputRef$cur === void 0 ? void 0 : _combinedInputRef$cur.focus();\n  };\n\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    extralarge: 'medium',\n    xlarge: 'medium' // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n\n  };\n  const showLeadingLoadingIndicator = loading && (loaderPosition === 'leading' || Boolean(LeadingVisual && loaderPosition !== 'trailing'));\n  const showTrailingLoadingIndicator = loading && (loaderPosition === 'trailing' || loaderPosition === 'auto' && !LeadingVisual);\n  return /*#__PURE__*/React.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual || showLeadingLoadingIndicator),\n    hasTrailingVisual: Boolean(TrailingVisual || showTrailingLoadingIndicator),\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: size && inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"leading\",\n    showLoadingIndicator: showLeadingLoadingIndicator\n  }, typeof LeadingVisual === 'function' ? /*#__PURE__*/React.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React.createElement(UnstyledTextInput, _extends({\n    ref: combinedInputRef,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), TokenComponent ? visibleTokens.map((_ref2, i) => {\n    let {\n      id,\n      ...tokenRest\n    } = _ref2;\n    return /*#__PURE__*/React.createElement(TokenComponent, _extends({\n      key: id,\n      onFocus: handleTokenFocus(i),\n      onBlur: handleTokenBlur,\n      onKeyUp: handleTokenKeyUp,\n      onClick: preventTokenClickPropagation,\n      isSelected: selectedTokenIndex === i,\n      onRemove: () => {\n        handleTokenRemove(id);\n      },\n      hideRemoveButton: hideTokenRemoveButtons,\n      size: size,\n      tabIndex: 0\n    }, tokenRest));\n  }) : null, tokensAreTruncated ? /*#__PURE__*/React.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: size && overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"trailing\",\n    showLoadingIndicator: showTrailingLoadingIndicator\n  }, typeof TrailingVisual === 'function' ? /*#__PURE__*/React.createElement(TrailingVisual, null) : TrailingVisual));\n}\n\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.defaultProps = {\n  tokenComponent: Token,\n  size: 'xlarge',\n  hideTokenRemoveButtons: false,\n  preventTokenWrapping: false,\n  loaderPosition: 'auto'\n};\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nexport default TextInputWithTokens;","map":{"version":3,"sources":["/Users/steve/Documents/repos/notifications/node_modules/@primer/react/lib-esm/TextInputWithTokens.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","FocusKeys","isFocusable","omit","React","useRef","useState","Box","useProvidedRefOrCreate","useCombinedRefs","useFocusZone","Text","Token","TextInputInnerVisualSlot","TextInputWrapper","textInputHorizPadding","UnstyledTextInput","overflowCountFontSizeMap","small","medium","large","extralarge","xlarge","TextInputWithTokensInnerComponent","externalRef","icon","IconComponent","leadingVisual","LeadingVisual","trailingVisual","TrailingVisual","loading","loaderPosition","contrast","className","block","disabled","sx","sxProp","tokens","onTokenRemove","tokenComponent","TokenComponent","preventTokenWrapping","size","hideTokenRemoveButtons","maxHeight","width","widthProp","minWidth","minWidthProp","maxWidth","maxWidthProp","validationStatus","variant","variantProp","visibleTokenCount","rest","onBlur","onFocus","onKeyDown","inputPropsRest","ref","localInputRef","combinedInputRef","selectedTokenIndex","setSelectedTokenIndex","tokensAreTruncated","setTokensAreTruncated","Boolean","containerRef","focusOutBehavior","bindKeys","ArrowHorizontal","HomeAndEnd","focusableElementFilter","element","getAttributeNames","includes","getNextFocusable","direction","_containerRef$current","undefined","nextIndex","current","children","handleTokenRemove","tokenId","setTimeout","_containerRef$current2","_containerRef$current3","nextElementToFocus","firstFocusable","Array","from","find","el","focus","_ref$current","handleTokenFocus","tokenIndex","handleTokenBlur","_containerRef$current4","contains","document","activeElement","handleTokenKeyUp","event","_ref$current2","handleInputFocus","handleInputBlur","_containerRef$current5","handleInputKeyDown","e","_ref$current3","value","lastToken","id","text","_ref$current4","select","focusInput","_combinedInputRef$cur","preventTokenClickPropagation","stopPropagation","visibleTokens","slice","inputSizeMap","showLeadingLoadingIndicator","showTrailingLoadingIndicator","createElement","hasLeadingVisual","hasTrailingVisual","onClick","paddingLeft","py","display","overflow","hasLoadingIndicator","visualPosition","showLoadingIndicator","alignItems","flexWrap","marginLeft","marginBottom","flexGrow","flexShrink","order","type","height","map","tokenRest","onKeyUp","isSelected","onRemove","hideRemoveButton","tabIndex","color","fontSize","displayName","TextInputWithTokens","forwardRef","defaultProps"],"mappings":"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","sourcesContent":["function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport { FocusKeys } from '@primer/behaviors';\nimport { isFocusable } from '@primer/behaviors/utils';\nimport { omit } from '@styled-system/props';\nimport React, { useRef, useState } from 'react';\nimport Box from './Box';\nimport { useProvidedRefOrCreate } from './hooks';\nimport { useCombinedRefs } from './hooks/useCombinedRefs';\nimport { useFocusZone } from './hooks/useFocusZone';\nimport Text from './Text';\nimport Token from './Token/Token';\nimport TextInputInnerVisualSlot from './_TextInputInnerVisualSlot';\nimport TextInputWrapper, { textInputHorizPadding } from './_TextInputWrapper';\nimport UnstyledTextInput from './_UnstyledTextInput'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  extralarge: 2,\n  xlarge: 2 // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n\n}; // using forwardRef is important so that other components (ex. Autocomplete) can use the ref\n\nfunction TextInputWithTokensInnerComponent({\n  icon: IconComponent,\n  leadingVisual: LeadingVisual,\n  trailingVisual: TrailingVisual,\n  loading,\n  loaderPosition,\n  contrast,\n  className,\n  block,\n  disabled,\n  sx: sxProp,\n  tokens,\n  onTokenRemove,\n  tokenComponent: TokenComponent,\n  preventTokenWrapping,\n  size,\n  hideTokenRemoveButtons,\n  maxHeight,\n  width: widthProp,\n  minWidth: minWidthProp,\n  maxWidth: maxWidthProp,\n  validationStatus,\n  variant: variantProp,\n  // deprecated. use `size` instead\n  visibleTokenCount,\n  ...rest\n}, externalRef) {\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useProvidedRefOrCreate(externalRef);\n  const localInputRef = useRef(null);\n  const combinedInputRef = useCombinedRefs(localInputRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return combinedInputRef.current || undefined;\n      }\n\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId); // HACK: wait a tick for the token node to be removed from the DOM\n\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0]; // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current;\n\n        // if there are no tokens left, focus the input\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n\n  const handleTokenFocus = tokenIndex => () => {\n    setSelectedTokenIndex(tokenIndex);\n  };\n\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current4;\n\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n\n  const handleInputBlur = event => {\n    onBlur && onBlur(event); // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n\n    setTimeout(() => {\n      var _containerRef$current5;\n\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n\n    const lastToken = tokens[tokens.length - 1];\n\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      } // HACK: for some reason we need to wait a tick for `.select()` to work\n\n\n      setTimeout(() => {\n        var _ref$current4;\n\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n\n  const focusInput = () => {\n    var _combinedInputRef$cur;\n\n    (_combinedInputRef$cur = combinedInputRef.current) === null || _combinedInputRef$cur === void 0 ? void 0 : _combinedInputRef$cur.focus();\n  };\n\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    extralarge: 'medium',\n    xlarge: 'medium' // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n\n  };\n  const showLeadingLoadingIndicator = loading && (loaderPosition === 'leading' || Boolean(LeadingVisual && loaderPosition !== 'trailing'));\n  const showTrailingLoadingIndicator = loading && (loaderPosition === 'trailing' || loaderPosition === 'auto' && !LeadingVisual);\n  return /*#__PURE__*/React.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual || showLeadingLoadingIndicator),\n    hasTrailingVisual: Boolean(TrailingVisual || showTrailingLoadingIndicator),\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: size && inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"leading\",\n    showLoadingIndicator: showLeadingLoadingIndicator\n  }, typeof LeadingVisual === 'function' ? /*#__PURE__*/React.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React.createElement(UnstyledTextInput, _extends({\n    ref: combinedInputRef,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), TokenComponent ? visibleTokens.map(({\n    id,\n    ...tokenRest\n  }, i) => /*#__PURE__*/React.createElement(TokenComponent, _extends({\n    key: id,\n    onFocus: handleTokenFocus(i),\n    onBlur: handleTokenBlur,\n    onKeyUp: handleTokenKeyUp,\n    onClick: preventTokenClickPropagation,\n    isSelected: selectedTokenIndex === i,\n    onRemove: () => {\n      handleTokenRemove(id);\n    },\n    hideRemoveButton: hideTokenRemoveButtons,\n    size: size,\n    tabIndex: 0\n  }, tokenRest))) : null, tokensAreTruncated ? /*#__PURE__*/React.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: size && overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), /*#__PURE__*/React.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"trailing\",\n    showLoadingIndicator: showTrailingLoadingIndicator\n  }, typeof TrailingVisual === 'function' ? /*#__PURE__*/React.createElement(TrailingVisual, null) : TrailingVisual));\n}\n\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.defaultProps = {\n  tokenComponent: Token,\n  size: 'xlarge',\n  hideTokenRemoveButtons: false,\n  preventTokenWrapping: false,\n  loaderPosition: 'auto'\n};\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nexport default TextInputWithTokens;"]},"metadata":{},"sourceType":"module"}
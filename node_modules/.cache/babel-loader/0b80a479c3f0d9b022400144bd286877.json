{"ast":null,"code":"import { useEffect, useCallback, useMemo } from 'react';\n/**\n * Calls all handlers in reverse order\n * @param event The KeyboardEvent generated by the Escape keydown.\n */\n\nfunction handleEscape(event) {\n  if (!event.defaultPrevented) {\n    for (const handler of Object.values(registry).reverse()) {\n      handler(event); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n      if (event.defaultPrevented) break;\n    }\n  }\n}\n\nconst registry = {};\n\nfunction register(id, handler) {\n  registry[id] = handler;\n}\n\nfunction deregister(id) {\n  delete registry[id];\n} // For auto-incrementing unique identifiers for registered handlers.\n\n\nlet handlerId = 0;\n/**\n * Sets up a `keydown` listener on `window.document`. If\n * 1) The pressed key is \"Escape\", and\n * 2) The event has not had `.preventDefault()` called\n * The given callback will be executed.\n *\n * Note: If multiple `useOnEscapePress` hooks are active simultaneously, the\n * callbacks will occur in reverse order. In other words, if a parent component\n * and a child component both call `useOnEscapePress`, when the user presses\n * Escape, the child component's callback will execute, followed by the parent's\n * callback. Each callback has the chance to call `.preventDefault()` on the\n * event to prevent further callbacks.\n *\n * @param callback {(e: KeyboardEvent) => void} The callback that gets executed\n * when the Escape key is pressed. The KeyboardEvent generated by the Escape\n * keypress is passed as the only argument.\n *\n * @param callbackDependencies {React.DependencyList} The dependencies of the given\n * `onEscape` callback for memoization. Omit this param if the callback is already\n * memoized. See `React.useCallback` for more info on memoization.\n */\n\nexport const useOnEscapePress = function (onEscape) {\n  let callbackDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [onEscape];\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const escapeCallback = useCallback(onEscape, callbackDependencies);\n  const handler = useCallback(event => {\n    if (event.key === 'Escape') escapeCallback(event);\n  }, [escapeCallback]);\n  const id = useMemo(() => handlerId++, []);\n  useEffect(() => {\n    if (Object.keys(registry).length === 0) {\n      document.addEventListener('keydown', handleEscape);\n    }\n\n    register(id, handler);\n    return () => {\n      deregister(id);\n\n      if (Object.keys(registry).length === 0) {\n        document.removeEventListener('keydown', handleEscape);\n      }\n    };\n  }, [id, handler]);\n};","map":{"version":3,"sources":["/Users/steve/Documents/repos/notifications/node_modules/@primer/react/lib-esm/hooks/useOnEscapePress.js"],"names":["useEffect","useCallback","useMemo","handleEscape","event","defaultPrevented","handler","Object","values","registry","reverse","register","id","deregister","handlerId","useOnEscapePress","onEscape","callbackDependencies","escapeCallback","key","keys","length","document","addEventListener","removeEventListener"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,WAApB,EAAiCC,OAAjC,QAAgD,OAAhD;AACA;AACA;AACA;AACA;;AAEA,SAASC,YAAT,CAAsBC,KAAtB,EAA6B;AAC3B,MAAI,CAACA,KAAK,CAACC,gBAAX,EAA6B;AAC3B,SAAK,MAAMC,OAAX,IAAsBC,MAAM,CAACC,MAAP,CAAcC,QAAd,EAAwBC,OAAxB,EAAtB,EAAyD;AACvDJ,MAAAA,OAAO,CAACF,KAAD,CAAP,CADuD,CACvC;;AAEhB,UAAIA,KAAK,CAACC,gBAAV,EAA4B;AAC7B;AACF;AACF;;AAED,MAAMI,QAAQ,GAAG,EAAjB;;AAEA,SAASE,QAAT,CAAkBC,EAAlB,EAAsBN,OAAtB,EAA+B;AAC7BG,EAAAA,QAAQ,CAACG,EAAD,CAAR,GAAeN,OAAf;AACD;;AAED,SAASO,UAAT,CAAoBD,EAApB,EAAwB;AACtB,SAAOH,QAAQ,CAACG,EAAD,CAAf;AACD,C,CAAC;;;AAGF,IAAIE,SAAS,GAAG,CAAhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMC,gBAAgB,GAAG,UAACC,QAAD,EAAiD;AAAA,MAAtCC,oBAAsC,uEAAf,CAACD,QAAD,CAAe;AAC/E;AACA,QAAME,cAAc,GAAGjB,WAAW,CAACe,QAAD,EAAWC,oBAAX,CAAlC;AACA,QAAMX,OAAO,GAAGL,WAAW,CAACG,KAAK,IAAI;AACnC,QAAIA,KAAK,CAACe,GAAN,KAAc,QAAlB,EAA4BD,cAAc,CAACd,KAAD,CAAd;AAC7B,GAF0B,EAExB,CAACc,cAAD,CAFwB,CAA3B;AAGA,QAAMN,EAAE,GAAGV,OAAO,CAAC,MAAMY,SAAS,EAAhB,EAAoB,EAApB,CAAlB;AACAd,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIO,MAAM,CAACa,IAAP,CAAYX,QAAZ,EAAsBY,MAAtB,KAAiC,CAArC,EAAwC;AACtCC,MAAAA,QAAQ,CAACC,gBAAT,CAA0B,SAA1B,EAAqCpB,YAArC;AACD;;AAEDQ,IAAAA,QAAQ,CAACC,EAAD,EAAKN,OAAL,CAAR;AACA,WAAO,MAAM;AACXO,MAAAA,UAAU,CAACD,EAAD,CAAV;;AAEA,UAAIL,MAAM,CAACa,IAAP,CAAYX,QAAZ,EAAsBY,MAAtB,KAAiC,CAArC,EAAwC;AACtCC,QAAAA,QAAQ,CAACE,mBAAT,CAA6B,SAA7B,EAAwCrB,YAAxC;AACD;AACF,KAND;AAOD,GAbQ,EAaN,CAACS,EAAD,EAAKN,OAAL,CAbM,CAAT;AAcD,CArBM","sourcesContent":["import { useEffect, useCallback, useMemo } from 'react';\n/**\n * Calls all handlers in reverse order\n * @param event The KeyboardEvent generated by the Escape keydown.\n */\n\nfunction handleEscape(event) {\n  if (!event.defaultPrevented) {\n    for (const handler of Object.values(registry).reverse()) {\n      handler(event); // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n      if (event.defaultPrevented) break;\n    }\n  }\n}\n\nconst registry = {};\n\nfunction register(id, handler) {\n  registry[id] = handler;\n}\n\nfunction deregister(id) {\n  delete registry[id];\n} // For auto-incrementing unique identifiers for registered handlers.\n\n\nlet handlerId = 0;\n/**\n * Sets up a `keydown` listener on `window.document`. If\n * 1) The pressed key is \"Escape\", and\n * 2) The event has not had `.preventDefault()` called\n * The given callback will be executed.\n *\n * Note: If multiple `useOnEscapePress` hooks are active simultaneously, the\n * callbacks will occur in reverse order. In other words, if a parent component\n * and a child component both call `useOnEscapePress`, when the user presses\n * Escape, the child component's callback will execute, followed by the parent's\n * callback. Each callback has the chance to call `.preventDefault()` on the\n * event to prevent further callbacks.\n *\n * @param callback {(e: KeyboardEvent) => void} The callback that gets executed\n * when the Escape key is pressed. The KeyboardEvent generated by the Escape\n * keypress is passed as the only argument.\n *\n * @param callbackDependencies {React.DependencyList} The dependencies of the given\n * `onEscape` callback for memoization. Omit this param if the callback is already\n * memoized. See `React.useCallback` for more info on memoization.\n */\n\nexport const useOnEscapePress = (onEscape, callbackDependencies = [onEscape]) => {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const escapeCallback = useCallback(onEscape, callbackDependencies);\n  const handler = useCallback(event => {\n    if (event.key === 'Escape') escapeCallback(event);\n  }, [escapeCallback]);\n  const id = useMemo(() => handlerId++, []);\n  useEffect(() => {\n    if (Object.keys(registry).length === 0) {\n      document.addEventListener('keydown', handleEscape);\n    }\n\n    register(id, handler);\n    return () => {\n      deregister(id);\n\n      if (Object.keys(registry).length === 0) {\n        document.removeEventListener('keydown', handleEscape);\n      }\n    };\n  }, [id, handler]);\n};"]},"metadata":{},"sourceType":"module"}
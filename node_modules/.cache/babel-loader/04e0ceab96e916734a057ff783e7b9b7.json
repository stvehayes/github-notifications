{"ast":null,"code":"/**\n * @module methodWrapperScoped\n *\n */\nimport matchKeys from '../lib/match_keys';\nimport parseKeys from '../lib/parse_keys';\n/**\n * methodWrapperScoped\n *\n * @access public\n * @param {object} args All args necessary for decorating the method\n * @param {object} args.target The decorated method's class object\n * @param {object} args.descriptor The method's descriptor object\n * @param {array} args.keys The key codes bound to the decorated method\n * @return {object} The method's descriptor object\n */\n\nfunction methodWrapperScoped(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n  var componentWillReceiveProps = target.componentWillReceiveProps;\n  var fn = descriptor.value;\n\n  if (!keys) {\n    console.warn(fn + ': keydownScoped requires one or more keys');\n  } else {\n    /**\n     * _shouldTrigger\n     *\n     * @access private\n     * @param {object} thisProps Exsting props from the wrapped component\n     * @param {object} thisProps.keydown The namespaced state from the higher-order\n     * component (class_decorator)\n     * @param {object} nextProps The incoming props from the wrapped component\n     * @param {object} nextProps.keydown The namescaped state from the higher-order\n     * component (class_decorator)\n     * @param {array} keys The keys bound to the decorated method\n     * @return {boolean} Whether all tests have passed\n     */\n    var _shouldTrigger = function _shouldTrigger(keydownThis, keydownNext) {\n      if (!(keydownNext && keydownNext.event && !keydownThis.event)) return false;\n      return keySets.some(function (keySet) {\n        return matchKeys({\n          keySet: keySet,\n          event: keydownNext.event\n        });\n      });\n    }; // wrap the component's lifecycle method to intercept key codes coming down\n    // from the wrapped/scoped component up the view hierarchy. if new keydown\n    // event has arrived and the key codes match what was specified in the\n    // decorator, call the wrapped method.\n\n\n    var keySets = parseKeys(keys);\n\n    target.componentWillReceiveProps = function (nextProps) {\n      var keydownNext = nextProps.keydown;\n      var keydownThis = this.props.keydown;\n\n      if (_shouldTrigger(keydownThis, keydownNext)) {\n        return fn.call(this, keydownNext.event);\n      }\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (componentWillReceiveProps) return componentWillReceiveProps.call.apply(componentWillReceiveProps, [this, nextProps].concat(args));\n    };\n  }\n\n  return descriptor;\n}\n\nexport default methodWrapperScoped;","map":{"version":3,"sources":["/Users/steve/Documents/repos/github-notifications/node_modules/react-keydown/es/decorators/method_decorator_scoped.js"],"names":["matchKeys","parseKeys","methodWrapperScoped","_ref","target","descriptor","keys","componentWillReceiveProps","fn","value","console","warn","_shouldTrigger","keydownThis","keydownNext","event","keySets","some","keySet","nextProps","keydown","props","call","_len","arguments","length","args","Array","_key","apply","concat"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,SAAP,MAAsB,mBAAtB;AACA,OAAOC,SAAP,MAAsB,mBAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,mBAAT,CAA6BC,IAA7B,EAAmC;AACjC,MAAIC,MAAM,GAAGD,IAAI,CAACC,MAAlB;AAAA,MACIC,UAAU,GAAGF,IAAI,CAACE,UADtB;AAAA,MAEIC,IAAI,GAAGH,IAAI,CAACG,IAFhB;AAGA,MAAIC,yBAAyB,GAAGH,MAAM,CAACG,yBAAvC;AAEA,MAAIC,EAAE,GAAGH,UAAU,CAACI,KAApB;;AACA,MAAI,CAACH,IAAL,EAAW;AACTI,IAAAA,OAAO,CAACC,IAAR,CAAaH,EAAE,GAAG,2CAAlB;AACD,GAFD,MAEO;AAEL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,QAAII,cAAc,GAAG,SAASA,cAAT,CAAwBC,WAAxB,EAAqCC,WAArC,EAAkD;AACrE,UAAI,EAAEA,WAAW,IAAIA,WAAW,CAACC,KAA3B,IAAoC,CAACF,WAAW,CAACE,KAAnD,CAAJ,EAA+D,OAAO,KAAP;AAE/D,aAAOC,OAAO,CAACC,IAAR,CAAa,UAAUC,MAAV,EAAkB;AACpC,eAAOlB,SAAS,CAAC;AAAEkB,UAAAA,MAAM,EAAEA,MAAV;AAAkBH,UAAAA,KAAK,EAAED,WAAW,CAACC;AAArC,SAAD,CAAhB;AACD,OAFM,CAAP;AAGD,KAND,CAfK,CAuBL;AACA;AACA;AACA;;;AAGA,QAAIC,OAAO,GAAGf,SAAS,CAACK,IAAD,CAAvB;;AAA8BF,IAAAA,MAAM,CAACG,yBAAP,GAAmC,UAAUY,SAAV,EAAqB;AACpF,UAAIL,WAAW,GAAGK,SAAS,CAACC,OAA5B;AACA,UAAIP,WAAW,GAAG,KAAKQ,KAAL,CAAWD,OAA7B;;AAGA,UAAIR,cAAc,CAACC,WAAD,EAAcC,WAAd,CAAlB,EAA8C;AAC5C,eAAON,EAAE,CAACc,IAAH,CAAQ,IAAR,EAAcR,WAAW,CAACC,KAA1B,CAAP;AACD;;AAED,WAAK,IAAIQ,IAAI,GAAGC,SAAS,CAACC,MAArB,EAA6BC,IAAI,GAAGC,KAAK,CAACJ,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAvB,CAAzC,EAAoEK,IAAI,GAAG,CAAhF,EAAmFA,IAAI,GAAGL,IAA1F,EAAgGK,IAAI,EAApG,EAAwG;AACtGF,QAAAA,IAAI,CAACE,IAAI,GAAG,CAAR,CAAJ,GAAiBJ,SAAS,CAACI,IAAD,CAA1B;AACD;;AAED,UAAIrB,yBAAJ,EAA+B,OAAOA,yBAAyB,CAACe,IAA1B,CAA+BO,KAA/B,CAAqCtB,yBAArC,EAAgE,CAAC,IAAD,EAAOY,SAAP,EAAkBW,MAAlB,CAAyBJ,IAAzB,CAAhE,CAAP;AAChC,KAd6B;AAe/B;;AAED,SAAOrB,UAAP;AACD;;AAED,eAAeH,mBAAf","sourcesContent":["/**\n * @module methodWrapperScoped\n *\n */\nimport matchKeys from '../lib/match_keys';\nimport parseKeys from '../lib/parse_keys';\n\n/**\n * methodWrapperScoped\n *\n * @access public\n * @param {object} args All args necessary for decorating the method\n * @param {object} args.target The decorated method's class object\n * @param {object} args.descriptor The method's descriptor object\n * @param {array} args.keys The key codes bound to the decorated method\n * @return {object} The method's descriptor object\n */\nfunction methodWrapperScoped(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n  var componentWillReceiveProps = target.componentWillReceiveProps;\n\n  var fn = descriptor.value;\n  if (!keys) {\n    console.warn(fn + ': keydownScoped requires one or more keys');\n  } else {\n\n    /**\n     * _shouldTrigger\n     *\n     * @access private\n     * @param {object} thisProps Exsting props from the wrapped component\n     * @param {object} thisProps.keydown The namespaced state from the higher-order\n     * component (class_decorator)\n     * @param {object} nextProps The incoming props from the wrapped component\n     * @param {object} nextProps.keydown The namescaped state from the higher-order\n     * component (class_decorator)\n     * @param {array} keys The keys bound to the decorated method\n     * @return {boolean} Whether all tests have passed\n     */\n    var _shouldTrigger = function _shouldTrigger(keydownThis, keydownNext) {\n      if (!(keydownNext && keydownNext.event && !keydownThis.event)) return false;\n\n      return keySets.some(function (keySet) {\n        return matchKeys({ keySet: keySet, event: keydownNext.event });\n      });\n    };\n\n    // wrap the component's lifecycle method to intercept key codes coming down\n    // from the wrapped/scoped component up the view hierarchy. if new keydown\n    // event has arrived and the key codes match what was specified in the\n    // decorator, call the wrapped method.\n\n\n    var keySets = parseKeys(keys);target.componentWillReceiveProps = function (nextProps) {\n      var keydownNext = nextProps.keydown;\n      var keydownThis = this.props.keydown;\n\n\n      if (_shouldTrigger(keydownThis, keydownNext)) {\n        return fn.call(this, keydownNext.event);\n      }\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (componentWillReceiveProps) return componentWillReceiveProps.call.apply(componentWillReceiveProps, [this, nextProps].concat(args));\n    };\n  }\n\n  return descriptor;\n}\n\nexport default methodWrapperScoped;"]},"metadata":{},"sourceType":"module"}
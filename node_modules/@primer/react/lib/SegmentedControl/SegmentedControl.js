"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SegmentedControl = void 0;

var _react = _interopRequireDefault(require("react"));

var _SegmentedControlButton = _interopRequireDefault(require("./SegmentedControlButton"));

var _SegmentedControlIconButton = _interopRequireDefault(require("./SegmentedControlIconButton"));

var _ = require("..");

var _sx = require("../sx");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const getSegmentedControlStyles = props => ({
  // TODO: update color primitive name(s) to use different primitives:
  // - try to use general 'control' primitives (e.g.: https://primer.style/primitives/spacing#ui-control)
  // - when that's not possible, use specific to segmented controls
  backgroundColor: 'switchTrack.bg',
  // TODO: update primitive when it is available
  borderColor: 'border.default',
  borderRadius: 2,
  borderStyle: 'solid',
  borderWidth: 1,
  display: props !== null && props !== void 0 && props.fullWidth ? 'flex' : 'inline-flex',
  height: '32px' // TODO: use primitive `primer.control.medium.size` when it is available

}); // TODO: implement `variant` prop for responsive behavior
// TODO: implement `loading` prop
// TODO: log a warning if no `ariaLabel` or `ariaLabelledBy` prop is passed
// TODO: implement keyboard behavior to move focus using the arrow keys


const Root = ({
  children,
  fullWidth,
  onChange,
  sx: sxProp = {},
  ...rest
}) => {
  const {
    theme
  } = (0, _.useTheme)();

  const selectedChildren = _react.default.Children.toArray(children).map(child => /*#__PURE__*/_react.default.isValidElement(child) && child.props.selected);

  const hasSelectedButton = selectedChildren.some(isSelected => isSelected);
  const selectedIndex = hasSelectedButton ? selectedChildren.indexOf(true) : 0;
  const sx = (0, _sx.merge)(getSegmentedControlStyles({
    fullWidth
  }), sxProp);
  return /*#__PURE__*/_react.default.createElement(_.Box, _extends({
    role: "toolbar",
    sx: sx
  }, rest), _react.default.Children.map(children, (child, i) => {
    if ( /*#__PURE__*/_react.default.isValidElement(child)) {
      return /*#__PURE__*/_react.default.cloneElement(child, {
        onClick: onChange ? e => {
          onChange(i);
          child.props.onClick && child.props.onClick(e);
        } : child.props.onClick,
        selected: i === selectedIndex,
        sx: {
          '--separator-color': i === selectedIndex || i === selectedIndex - 1 ? 'transparent' : theme === null || theme === void 0 ? void 0 : theme.colors.border.default
        }
      });
    }
  }));
};

Root.displayName = "Root";
Root.displayName = 'SegmentedControl';
const SegmentedControl = Object.assign(Root, {
  Button: _SegmentedControlButton.default,
  IconButton: _SegmentedControlIconButton.default
});
exports.SegmentedControl = SegmentedControl;